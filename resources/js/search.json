[[{"l":"hello bro"}],[{"l":"Giới thiệu về lập trình thi đấu","p":["Rất cảm ơn SmolLemon, một thành viên của ChuyentinORZ, đã contribute cho ChuyentinORZ Wiki! Các bạn có thể xem repo gốc tại đây. SmolBook is licensed under CC-BY-SA 4.0","Lập trình thi đấu, tên tiếng anh là competitive programming, về cơ bản là một bộ môn thể thao, nơi thí sinh viết nên các chương trình máy tính để giải quyết các bài toán."]},{"l":"Tổng quan","p":["Việc giải một bài toán về lập trình thi đấu sẽ bao gồm 2 bước chính: Thiết kế thuật toán và cài đặt thuật toán.","Việc thiết kế thuật toán sẽ yêu cầu ta thiết kế một thuật toán phù hợp để giải quyết bài toán. Nó yêu cầu ta phải có kĩ năng tư duy giải quyết vấn đề và cả tư duy toán học. Thuật toán cần phải nhanh và hiệu quả để có thể giải quyết được bài toán.","Thông thường, các bài toán thường sẽ liên quan đến những chủ đề khác nhau: tổ hợp, lí thuyết số, lí thuyết đồ thị, lí thuyết trò chơi, xử lí xâu, cấu trúc dữ liệu,... và việc áp dụng những kiến thức này cộng thêm với các hướng giải quyết mới sẽ giúp ta thiết kế được một thuật toán hiệu quả.","Việc cài đặt thuật toán là quá trình thực hiện hóa thuật toán mà ta đã nghĩ ra. Sự hiểu biết về ngôn ngữ lập trình và cách áp dụng nó vào việc cài đặt thuật toán mà một yêu cầu hết sức quan trọng trong quá trình giải quyết bài toán.","Các chương trình cần được viết một cách ngắn gọn và xúc tích (một chương trình dài nhất cũng chỉ tầm vài trăm dòng) bởi trong các cuộc thi lập trình, thời gian là có hạn. Đồng thời, các chương trình cũng phải thỏa mãn những giới hạn mà bài toán đề ra về thời gian thực thi chương trình và giới hạn bộ nhớ mà chương trình được phép sử dụng."]},{"l":"Một chương trình điển hình","p":["Accepted (AC)","Bài toán A + B","Bài toán cho ta 2 số A và B và yêu cầu ta tính tổng của hai số ấy. Dữ liệu nhập sẽ là 2 số A và B trên một dòng dòng và yêu cầu ta in ra tổng hai số.","Chương trình bị lỗi biên dịch.","Chương trình chạy quá thời gian quy định.","Chương trình cho ra kết quả sai.","Chương trình gặp lỗi khi chạy.","Chương trình in kết quả đúng và thỏa mãn các yêu cầu của bài.","Chương trình in ra quá nhiều dữ liệu.","Chương trình sử dụng bộ nhớ nhiều hơn quy định.","Compilation Error (CE)","Internal Error (IE)","Kết quả","Khi ta nộp chương trình, máy chấm sẽ chạy chương trình với một danh sách các dữ liệu nhập (testcase) và kiểm tra đáp án mà chương trình in ra với đáp án của mỗi testcase tương ứng. Với mỗi testcase, máy chấm sẽ trả về cho ta một trong các kết quả sau đây:","Lỗi đến từ hệ thống máy chấm.","Memory Limit Exceeded (MLE)","Một chương trình máy tính được viết ra bởi thí sinh để giải một bài toán cụ thể sẽ lấy dữ liệu nhập ( input) và xuất dữ liệu ( output) chứa đáp án đúng tương ứng.","Output Limit Exceeded (OLE)","Runtime Error (RTE)","Ta ví dụ với bài toán A cộng B:","Time Limit Exceeded (TLE)","Tùy theo thể thức mà điểm cho mỗi bài sẽ khác nhau. Có thể thức sẽ tính điểm theo số lượng testcase AC/số lượng testcase, có thể thức chỉ cho điểm khi ta AC toàn bộ các testcase.","Wrong Answer (WA)","Ý nghĩa"]},{"l":"Subtask","p":["Một số bài toán sẽ chia các testcase theo các nhóm khác nhau, giúp thí sinh giành được một phần điểm số cho bài toán. Các nhóm testcase này được gọi là subtask. Các subtask thường sẽ chứa những testcase có giới hạn nhỏ hơn giới hạn bài toán, hoặc có một số tính chất đặc biệt nào đó, hoặc cả hai."]},{"i":"vì-sao-cần-lập-trình-thi-đấu","l":"Vì sao cần lập trình thi đấu?","p":["Việc giải các bài toán và tham gia các cuộc thi lập trình thi đấu có thể giúp các thí sinh có hứng thú với các ngành liên quan đến khoa học máy tính. Những kiến thức học được từ lập trình thi đấu cũng cải thiện khả năng lập trình và tư duy logic của các lập trình viên, giúp họ có lợi thế trong công việc."]},{"l":"Các cuộc thi lập trình","p":["Có vô số cuộc thi lập trình phổ biến trên toàn quốc và quốc tế. Ta cùng điểm qua một số cuộc thi tiêu biểu."]},{"i":"kì-thi-học-sinh-giỏi-cấp-trườngthành-phốtỉnh-môn-tin-học","l":"Kì thi Học sinh giỏi cấp trường/thành phố/tỉnh (môn Tin học)","p":["Mục đích của các cuộc thi này nhằm động viên, khuyến khích học sinh và giáo viên phát huy và nâng cao năng lực của bản thân, đồng thời phát hiện và bồi dưỡng những học sinh có năng khiếu ở các môn học."]},{"i":"kỳ-thi-olympic-truyền-thống-304-môn-tin-học","l":"Kỳ thi Olympic truyền thống 30/4 (môn Tin học)","p":["Cuộc thi Olympic truyền thống 30/4 là một cuộc thi học sinh giỏi hàng năm dành cho học sinh khối 10 và 11 của khu vực phía Nam. Cuộc thi này do trường THPT Chuyên Lê Hồng Phong TPHCM sáng lập và được tổ chức lần đầu tiên vào năm 1995 với mục đích phát hiện, bồi dưỡng những học sinh có năng khiếu thuộc các khối lớp 10 và 11, chuẩn bị đội ngũ cho kỳ thi học sinh giỏi quốc gia, tạo điều kiện cho việc giao lưu học hỏi giữa các học sinh giỏi và trao đổi chuyên môn giữa các thầy cô dạy lớp chuyên của các tỉnh phía Nam[^ 1]."]},{"i":"kỳ-thi-chọn-học-sinh-sinh-giỏi-khu-vực-duyên-hải-và-đồng-bằng-bắc-bộ-môn-tin-học","l":"Kỳ thi chọn Học sinh sinh giỏi khu vực Duyên Hải và đồng bằng Bắc Bộ (môn Tin học)","p":["Kỳ thi do Hội các trường THPT chuyên khu vực duyên hải và đồng bằng Bắc Bộ tổ chức hằng năm. Kỳ thi là dịp phát hiện học sinh giỏi, học sinh xuất sắc các bộ môn để các trường THPT chuyên có kế hoạch lựa chọn, bồi dưỡng các em tham gia các kỳ thi học sinh giỏi quốc gia, khu vực và quốc tế. Đồng thời là dịp để đội ngũ cán bộ quản lý và giáo viên các trường THPT chuyên trao đổi, chia sẻ kinh nghiệm, nâng cao trình độ chuyên môn bồi dưỡng môn chuyên và học sinh giỏi[^ 2]."]},{"i":"kì-thi-chọn-học-sinh-giỏi-quốc-gia-môn-tin-học","l":"Kì thi chọn Học sinh giỏi Quốc gia (môn Tin học)","p":["Kỳ thi chọn học sinh giỏi quốc gia trung học phổ thông(viết tắt là Kỳ thi HSGQG) là kỳ thi chọn học sinh giỏi cấp quốc gia dành cho học sinh bậc trung học phổ thông do Bộ Giáo dục và Đào tạo tổ chức vào khoảng từ tháng 12 đến tháng 1 hằng năm. Những học sinh đạt điểm cao nhất trong kỳ thi này ở một vài bộ môn được Bộ Giáo dục và Đào tạo triệu tập tại Hà Nội, Việt Nam để tham gia kỳ thi chọn các học sinh vào đội tuyển Quốc gia Việt Nam tham dự các cuộc thi Olympic khu vực và quốc tế[^ 3].","Ở bộ môn tin học, cuộc thi có tên gọi không chính thức là VOI - Vietnamese Olympiad in Informatics."]},{"l":"Hội thi Tin học trẻ các cấp","p":["Hội thi Tin học trẻ là kì thi tin học thường niên dành cho các học sinh các cấp. Đây là sân chơi uy tín trong lĩnh vực tin học, do Trung ương Đoàn, Bộ Khoa học và Công nghệ, Bộ Giáo dục và Đào tạo, Bộ Thông tin và Truyền thông và Hội Tin học Việt Nam phối hợp tổ chức thường niên từ năm 1995."]},{"i":"olympic-tin-học-quốc-tế-ioi","l":"Olympic Tin học Quốc tế (IOI)","p":["Olympic Tin học Quốc tế( International Olympiad in Informatics - IOI) là một cuộc thi quốc tế lập trình thi đấu thường niên dành cho học sinh trung học (cấp 2 và 3). Cuộc thi đầu tiên được tổ chức vào năm 1989 tại Bulgaria."]},{"l":"ICPC","p":["International Collegiate Programming Contest, hay ICPC, là một cuộc thi lập trình dành cho sinh viên. Đây là cuộc thi lập trình lâu đời nhất, lớn nhất và danh tiếng nhất thế giới. Hằng năm, cuộc thi thu hút hơn 50000 thí sinh từ hơn 3000 trường đại học khác nhau trên toàn thế giới. [^ 4]","Mặc dù cuộc thi chỉ giới hạn cho các trường đại học, ở Việt Nam, ban tổ chức ICPC Việt Nam cũng tổ chức Kì thi ICPC cho các bạn học sinh THPT trên khắp cả nước."]},{"l":"Các cuộc thi online","p":["Ngoài các cuộc thi lập trình thi đấu trực tiếp, nhiều trang web được tạo ra nhằm hỗ trợ và cung cấp nhiều điều bổ ích cho các thí sinh trên toàn thế giới. Các trang như VNOJ, Codeforces, Atcoder,... là một trong những ví dụ điển hình. Các trang này tổ chức các cuộc thi online, có nhiều dạng bài phong phú, một số trang còn hỗ trợ tìm kiếm việc làm liên quan đến lập trình!","Kì thi Olympic truyền thống 301 lần thứ XXVI năm 2021 - THPT Lê Hồng Phong","Gần 2.000 học sinh khu vực duyên hải và đồng bằng Bắc Bộ thi chọn học sinh giỏi tại TP Hải Dương - Báo Hải Dương","Kỳ thi chọn HSG Quốc Gia THPT - Wikipedia"]}],[{"l":"Chọn ngôn ngữ lập trình","p":["Ngôn ngữ lập trình C++ là một trong ngôn ngữ được sử dụng phổ biến, nếu không muốn nói là phổ biến nhất trong lập trình thi đấu. Chính vì thế, tất cả các đoạn code được viết trong Smol Book đều sẽ được viết trên C++, phiên bản C++ 14 để phù hợp với Themis [Θέμις]- Chương trình chấm bài tự động- phần mềm chấm thi chính thức của Bộ Giáo dục và Đào tạo, thường xuyên được sử dụng để chấm thi trong các kỳ thi Học sinh giỏi cấp Tỉnh, Khu vực và Quốc gia - chạy chương trình C++ với phiên bản C++ 14."]},{"i":"lập-trình-c","l":"Lập trình C++","p":["Đối với C++ nói riêng và ngôn ngữ lập trình nói chung, những kiến thức về nhập xuất dữ liệu, câu lệnh lặp, lệnh rẽ nhánh, chương trình con là quá đủ để giải quyết hầu hết các yêu cầu về cài đặt của thuật toán. Những tính năng cụ thể về ngôn ngữ lập trình ví vụ như Con trỏ, Tham chiếu,... trong C++ có thể học sau.","Bạn có thể tham khảo Một số mẹo khi lập trình C++ trong lập trình thi đấu."]},{"i":"cài-đặt-môi-trường-code-c","l":"Cài đặt môi trường code C++","p":["Để chạy chương trình code C++, bạn cần 2 phần mềm chính.","Trình biên dịch C++(Compiler)","Trình soạn thảo văn bản (Text editor)","GNU Compiler Collection (GCC) là một trình biên dịch C++ vô cùng phổ biến. Người dùng Windows có thể tải MinGW để sử dụng GCC, hoặc tải g++ thông qua package manager cho người dùng GNU+ Linux/MacOS. Một trong các IDE được sử dụng rộng rãi trong các máy thi là Code::Blocks. Trên các máy Windows, để tải về Code::Blocks, ta truy cập trang web của Code::Blocks và tải về phiên bản mingw-setup bằng 1 trong 2 đường dẫn mà trang chỉ ta đến, sau đó thực hiện việc tải Code::Blocks.","Tải về Codeblock"]},{"i":"cài-đặt-codeblocks-cho-lập-trình-thi-đấu","l":"Cài đặt Code::Blocks cho lập trình thi đấu","p":["Code::Blocks trong các máy thi thường hoặc là mới được tải về hoặc là đang sử dụng các cài đặt mặc định. Mặc định, Code::Blocks sẽ cho trình biên dịch C++ biên dịch chương trình của ta theo tiêu chuẩn C 98 (compiler tiêu chuẩn từ hơn 26 năm về trước). Để Code::Block chạy đúng chương trình của ta với tiêu chuẩn mới của C, ta thực hiện các bước sau.","Từ thanh menu, chọn Settings - Compiler.","Ở phần Select compiler chọn GNU GCC Compiler làm trình biên dịch C++.","Ở phần Compiler Flags, đánh dấu tích ở phần Have g++ follow the C++14 ISO C++ language standard [-std=c++14]","Nếu trong Code::Blocks không có ô chọn biên dịch theo tiêu chuẩn C++ 14 như trên thì ta sang phần Other compiler options và thêm -std=c++14 vào để cho kết quả tương đương.","Ngoài việc thêm flag -std=c++14 để trình biên dịch biên dịch theo tiêu chuẩn C++ 14, ta còn thêm một số flag để giúp ta trong việc lập trình:","Enable all common compiler warnings (overrides many other settings) [-Wall]","Enable extra compiler warnings [-Wextra]","Optimize even more (for speed) [-O2]","Các flag này sẽ cảnh bảo ta về một số cảnh báo khi ta chương trình (-Wall, -Wextra) và tối ưu chương trình khi chạy (-O2)."]}],[{"l":"Nhập xuất dữ liệu","p":["Trong các bài toán lập trình, bài sẽ yêu cầu ta nhập vào dữ liệu, và in ra kết quả tương ứng. Ta sẽ ví dụ về cách nhập xuất dữ liệu trong C++ thông qua các bài ví dụ sau:","Nhập hai số a và b, yêu cầu in ra tổng hai số. Input:","Output:","Một cách để nhập dữ liệu phổ biến trong C++ chính là sử dụng std::cin.","Với một đoạn thông tin nó sẽ nhập vào và kết thúc khi xuất hiện dấu cách hoặc dấu xuống dòng. Vậy nên khi dữ liệu nhập có dạng như dưới đây thì đoạn code vẫn sẽ nhập vào hai số như bình thường:","Đối với việc xuất dữ liệu, ta sử dụng std::cout.","Việc nhập xuất dữ liệu liên tục sẽ giảm hiệu suất của chương trình, dẫn đến TLE. Ta áp dụng Fast I/O để tối ưu quá trình này. Ta cũng có thể sử dụng scanf/printf của C để nhập dữ liệu. Phương pháp này tuy nhanh hơn so với C++(lúc chưa có Fast I/O), nhưng lại khó dùng hơn một chút. Dưới đây là đoạn code sử dụng scanf/printf:","Ta có thể sử dụng lẫn lộn cả hai cách nhập trong chương trình. Lưu ý rằng khi sử dụng Fast I/O thì không nên làm điều này.","Đối với những bài yêu cầu đọc/ghi dữ liệu vào file, ta có thể làm điều này một cách đơn giản bằng cách sử dụng freopen:"]},{"l":"Một số yêu cầu đặc biệt cho mỗi bài"},{"l":"Nhập nhiều số với số lượng không xác định","p":["Đối với các bài có số lượng dữ liệu nhập không xác định, ta có thể viết code như sau:"]},{"l":"Nhập xâu trên một dòng","p":["Giả sử đề yêu cầu ta nhập một xâu có trên một hàng, ví dụ như:","Và ta viết dòng lệnh:","Xâu s của ta sẽ chỉ lưu abc thay vì abc def như ta mong muốn. Đấy là bởi vì cin sẽ chỉ nhập các kí tự liên tiếp cho tới khi có dấu cách, xuống dòng hoặc đến cuối file. Để có thể nhập toàn bộ kí tự có trên một dòng, ta dùng lệnh getline:"]},{"l":"Nhập nhiều số với số lượng không xác định trên nhiều dòng","p":["Đây là kết hợp giữa hai dạng trên. Ta có bài toán yêu cầu ta tính tổng các số trên mỗi hàng với số lượng không xác định.","Các dòng 1, 2, 3 lần lượt có tổng là 10, 3570 và 223. Để giải quyết bài toán này, ta sử dụng stringstream:"]}],[{"l":"Các kiểu dữ liệu","p":["-2 15 đến -2 15- 1","-2 31 đến 2 31- 1","-2 63 đến 2 63- 1","-2 7 đến 2 7- 1","≈ -1.7 x 10 308 đến ≈ 1.7 x 10 308","≈ -3,4 x 10 38 đến ≈ 3.4 x 10 38","1","2","4","8","bool","char","Dãy giá trị","double","float","Giá trị đúng/sai","int","Kí tự","Kích cỡ (bytes)","Loại dữ liệu","long long","Ở C++ và nhiều ngôn ngữ lập trình ta sẽ bắt gặp các kiểu dữ liệu được biểu diễn ở dạng nhị phân như sau:","short int","Số nguyên 16 bit","Số nguyên 32 bit","Số nguyên 64 bit","Số thực độ chính xác đơn","Số thực độ chính xác kép","Tên dữ liệu","true hoặc false(0 hoặc 1)"]},{"l":"Số nguyên","p":["int, short int, long long dùng để lưu số nguyên. Các kiểu dữ liệu này có thể lưu các số nguyên không dấu(lưu các số nguyên không âm), hoặc có dấu(có thể lưu các số nguyên âm). Để lưu các số nguyên không dấu, ta viết thêm unsigned ở đầu kiểu dữ liệu. VD:","Khi lưu các số nguyên có dấu ta không cần viết signed ở đầu kiểu dữ liệu.","Trong C++, phép % dùng để lấy phần dư của một số. Khi dùng phép % với số âm thì kết quả sẽ là \\(0\\) hoặc là một số âm. Nếu tìm modulo của một số âm bằng phép % thì ta thực hiện: ((a % b) + b) % b."]},{"l":"Số thực","p":["float, double dùng để lưu các số thực. 2 cách lưu trữ số này chỉ lưu các số thập phân chính xác một phần: float có thể lưu chính xác đến khoảng 7 số sau dấu chấm phẩn, double gấp đôi: 14 đến 15 số. Ta không nên so sánh 2 số thực bằng kí tự ==. Nếu ta chạy:","Thì nó sẽ in False thay vì True. Các bài tập yêu cầu in số thực sẽ chấp nhận kết quả chương trình của bạn nếu chệnh lệnh của đáp án của bạn và đáp án của bài nằm trong khoảng yêu cầu ví dụ như 10 9.","Nếu output là x và đáp án của test là y thì chênh lênh sẽ là |x-y|. Các biến số thực vẫn có thể lưu chính xác nếu nó được yêu cầu lưu các số nguyên."]},{"l":"Boolean","p":["bool dùng để lưu 2 giá trị True/False (1/0). Bool lại dùng đến 8 bit để lưu true/false trong khi có thể dùng 1 bit để làm điều tương tự. Ta có thể dùng bitset để có thể tối ưu bộ nhớ."]},{"l":"Kí tự","p":["char lưu kí tự theo bộ mã ASCII. Ta có thể chuyển từ kí tự sang số bằng cách dùng câu lệnh int([kí_tự]), hoặc chuyển một số sang một kí tự bằng char([mã số]). Mã số của các kí tự quen thuộc trong ASCII:","Mã số của các kí tự từ 1 đến 10 là từ 48 đến 57.","Mã số của các kí tự từ a đến z là từ 97 đến 122.","Mã số của các kí tự từ A đến Z là từ 65 đến 90.","Ta có thể chuyển từ kí tự in thường sang in hoa và ngược lại bằng cách trừ hoặc cộng 32."]},{"l":"Xâu kí tự","p":["string là một chuối kí tự chứa các giá trị char."]}],[{"i":"mẹo-lập-trình-thi-đấu-c","l":"Mẹo lập trình thi đấu C++","p":["Dưới đây là một số mẹo cho C++ trong lập trình thi đấu."]},{"i":"fast-io","l":"Fast I/O","p":["Trong hầu hết các bài nộp C++, ta thường bắt gặp 2 dòng lệnh phổ biến ở đầu hàm main:","2 câu lệnh này giúp tăng tốc chương trình bằng cách thay đổi cách nhập xuất của nó.","ios_base::sync_with_stdio(false) tắt đồng bộ giữa cách nhập xuất của C và C++. Tính năng này giúp ta có thể sử dụng linh hoạt giữa hai cách nhập xuất khác nhau. Khi tắt tính năng này, chương trình của ta sẽ chạy nhanh hơn nếu bài toán yêu cầu nhập xuất dữ liệu nhiều lần. Lưu ý rằng nếu tắt đồng bộ thì không nên sử dụng đồng thời 2 cách nhập xuất.","cin.tie(NULL) tắt đồng bộ giữa cin và cout. tie() được dùng để đảm bảo tất cả các dữ liệu của cout sẽ được xuất ra màn hình trước khi thực hiện cin nhập dữ liệu. Điều này sẽ giúp ích cho các chương trình cần sự tương tác giữa người và chương trình, hoặc chương trình và chương trình - thứ mà ngoài dạng bài toán tương tác ra thì không cần thiết trong lập trình thi đấu. Việc tương tác này sẽ chương trình của ta sẽ chạy chậm đi. Ta tắt tính năng này để gia tăng tốc độ chương trình."]},{"i":"sử-dụng-n-thay-thế-cho-endl","l":"Sử dụng '\\n' thay thế cho endl","p":["Trong lập trình thi đấu, sẽ tốt hơn nếu ta sử dụng '\\n' để xuống dòng thay vì sử dụng endl. Ta có thể hiểu endl giống như khi ta viết '\\n' flush. flush là thao tác đẩy dữ liệu từ bộ đệm đầu ra (output buffer) ra thiết bị đầu ra. Nói cách khác, nó đảm bảo rằng tất cả dữ liệu đang chờ trong bộ đệm sẽ được ghi ra màn hình. Khi flush thường xuyên sẽ giảm hiệu suất của ta, việc dùng'\\n' để xuống dòng trong các chương trình sẽ cho ta tốc độ chạy code nhanh hơn so với việc sử dụng endl."]},{"l":"Rút gọn code"},{"l":"Type name","p":["Ta có thể dùng typedef để rút gọn chương trình của ta. VD:","Sẽ giúp làm ngắn code:","thành:"]},{"l":"Macros","p":["Macro thay đổi kí tự hoặc xâu kí tự trong mã (code) khi biên dịch chương trình. Trong C++ macro được định nghĩa bằng #define {Tên_macro} {macro}. VD:"]},{"l":"Xuống dòng","p":["Dưới đây là một đoạn của một chương trình in ra các giá trị của một mảng \\(2\\) chiều kích thước n * m:","Thay vì phải in thêm một câu lệnh cout sau mỗi lần in xong một hàng, ta có cách viết khác:","Dòng lệnh này có ý nghĩa: \\n là một xâu kí tự, trong khi ta chưa duyệt đến phần tử cuối cùng, điều kiện j m thỏa mãn, chương trình in ra kí tự vị trí 1 của xâu: ' '- dấu cách. Khi đã duyệt đến phần tử cuối cùng, điều kiện j m không thỏa mãn, chương trình in ra kí tự vị trí 0 của xâu: '\\n'- xuống dòng."]},{"l":"Viết số lớn","p":["Sẽ có nhiều bài yêu cầu ta phải tạo một mảng lớn (như 10 6 chẳng hạn), nhiều người có thể sẽ viết một mảng a và số 10 6 cộng thêm một số nhỏ như 10: a[1000010]. Kiểu viết này tuy không sai nhưng rất dễ xảy ra lỗi.","Đồng thời, khi sửa lại kích thước mảng cũng rất khó khăn khi ta phải sửa lại tất cả các số ấy. Nếu ta muốn đổi kích thước của các mảng ví dụ trên thì ta viết lại 6 lần! Ta tạo một hằng số N tượng trưng cho kích thước của mảng. Ta cho N = 1e6 + 10 với giá trị bằng 1000010, vừa dễ nhìn vừa khó mắc lỗi, đồng thời cũng dễ sửa hơn.","Chữ e(hoặc E) trong đoạn code là E notation. Khi viết mEn sẽ có giá trị: m × n 10. VD:","1e6 = 10^6 = 1000000","2e5 = 2 * 10^5 = 200000"]},{"l":"Câu lệnh rẽ nhánh trong một dòng","p":["Có những lần bạn phải gán giá trị theo từng trường hợp:","Ta có thể rút gọn lại thành:"]},{"l":"For auto","p":["Mẹo chỉ áp dụng với tiêu chuẩn C++ 17.","Giả sử ta có một vector chứa pair, và ta muốn in ra các giá trị của từng pair trong vector, ta làm như sau:","Thay vào đó, ta có thể viết theo cách khác:"]},{"i":"khai-báo-hàm-ở-dưới-hàm-main","l":"Khai báo hàm ở dưới hàm main()","p":["Xin nói trước rằng đây không hẳn là một mẹo và nói đúng hơn thì nó là một sở thích cá nhân khi viết code lập trình thi đấu của tác giả.","Các chương trình C++ khi khai báo các chương trình con thường sẽ viết như sau:","Ta cũng có thể khai báo theo cách khác:","Tại sao lại khai báo hàm dưới hàm main()? Ta có một số lợi ích khi khai báo hàm theo cách này: Lợi ích 1: Dễ phân tích code. Với cách viết này, ta có thể phân tích code từ trên xuống một cách dễ dàng: Ta biết được các hàm có trong chương trình ở ngay đầu chương trình một cách ngắn gọn (mỗi dòng 1 hàm), biết được các hàm được sử dụng như thế nào trong hàm main() ngay sau đó, và biết cách hoạt động của các hàm ở cuối chương trình. Còn cách viết ở trên thì ta phải lướt lên lướt xuống để làm được những điều tương tự. Lợi ích 2: Không xuất hiện lỗi khi có các hàm phụ thuộc lẫn nhau. Ta có chương trình sau:","Chương trình ở trên sẽ không chạy được do hàm odd() được khai báo trước hàm even(), từ đó \"không thấy\" hàm ấy. Vẫn đề đó sẽ không tồn tại nếu ta viết theo cách sau:","Bằng cách khai báo các hàm ở dưới hàm main, ta tránh được lỗi xảy ra khi các hàm phụ thuộc lẫn nhau. Tuy nhiên, cách viết này cũng tồn tại một vài bất lợi, cụ thể là khi sửa các hàm ta phải sửa tận 2 vị trí thay vì 1."]}],[{"l":"Kiến thức toán cơ bản","p":["Toán học có vai trò quan trọng trong lập trình thi đấu. Việc bạn giỏi toán, hoặc có khá năng tư duy toán học tốt là một lợi thế so với những người khác. Ta sẽ nói về một số kiến thức cơ bản có tính ứng dụng cao trong lập trình thi đấu."]},{"l":"Công thức tính tổng","p":["Ta có công thức tính tổng của một số dãy số: Tổng của n số tự nhiên đầu tiên:","1 + 2 + ... + n = \\frac{n(n + 1)}{2}","Tổng lũy thừa của n số tự nhiên đầu tiên:","1^2 + 2^2 + ... + n^2 = \\frac{n(n + 1)(2n + 1)}{6}","Tổng của một cấp số cộng u_n với số hạng đầu u_1 và công sai d:","u_1 + u_2 + ... + u_n = \\frac{n[2u_1 + (n - 1)d]}{2} = \\frac{n(u_1 + u_n)}{2}","Tổng của một cấp số nhân u_n với số hạng đầu u_1 và công bội q \\neq 1:","u_1 + u_2 + ... + u_n = \\frac{u_1(q^n - 1)}{q - 1}","Từ đây ta có tổng của $n$lũy thừa đầu tiên của 2 bằng:","1 + 2 + ... + 2^{n - 1} = 2^n - 1"]},{"l":"Lý thuyết tập hợp","p":["Một tập hợp là một bộ các phần tử. Ví dụ với tập hợp X:","X = {2, 3, 5}","chứa các phần tử 2, 3, 5. Một tập hợp không chứa phần tử được gọi là tập rỗng. Kí hiệu là \\emptyset. Ta sử dụng kí hiệu \\in hoặc \\notin để biểu thị nếu phần tử có nằm trong tập hợp hay không. Ví dụ với tập hợp X ở trên, 2 thuộc tập hợp X nên ta viết 2 \\in X, 1 không thuộc tập hợp X nên ta viết 1 \\notin X.","Ta kí hiệu số lượng các phần tử trong tập X là |X|. Chẳng hạn, tập hợp X ở trên có |X| = 3 phần tử.","Một tập hợp Y mà tất cả các phần tử nằm trong Y đều nằm trong X thì ta nói tập hợp Y là con của tập hợp X. Kí hiệu Y \\subset X.","Một tập hợp X sẽ có 2^{|X|} tập con khác nhau. Đối với tập hợp X ở trên sẽ có các tập hợp con:","\\emptyset, \\\\{2\\\\}, \\\\{3\\\\}, \\\\{5\\\\}, \\\\{2, 3\\\\}, \\\\{2, 5\\\\}, \\\\{3, 5\\\\}, \\\\{2, 3, 5\\\\}","Ta có các phép toán trên tập hợp:","Giao của hai tập hợp X và Y là một tập hợp có các phần tử nằm trong cả tập X và tập Y, kí hiệu X \\cap Y. Nếu X = {1, 2, 4} và Y = {1, 4, 5} thì X \\cap Y = {1, 4}. Hợp của hai tập hợp X và Y là một tập hợp có các phần tử nằm trong một trong hai tập X và Y hoặc cả hai, kí hiệu X \\cup Y. Nếu X = {1, 2, 4} và Y = {1, 4, 5} thì X \\cup Y = {1, 2, 4, 5}. Hiệu của hai tập hợp X và Y là một tập hợp có các phần tử nằm trong tập X nhưng không nằm trong tập Y, kí hiệu X \\setminus Y. Nếu X = {1, 2, 4} và Y = {1, 4, 5} thì X \\setminus Y = {1}. Nếu Y \\subset X thì X \\setminus Y được gọi là phần bù của Y trong X, kí hiệu C_X Y. Trong toán học ta cũng có kí hiệu cho các tập hợp số.","Tập hợp các số tự nhiên: \\mathbb{N} = {0, 1, 2, ... }","Tập hợp các số nguyên: \\mathbb{Z} = {..., -2, -1, 0, 1, 2, ... }","Tập hợp các số hữu tỉ: \\mathbb{Q} = {0, 7, \\frac{1}{2} ... }","Tập hợp các số vô tỉ: \\mathbb{R} = {\\pi, e, \\sqrt{2} ... }","Mối quan hệ giữa các tập hợp số: \\mathbb{N} \\subset \\mathbb{Z} \\subset \\mathbb{Q} \\subset \\mathbb{R}"]},{"l":"LLogarit","p":["Định nghĩa của logarit được phát biểu như sau:","Cho a là một số thực khác 0 và một số thực x. Số thực k để a^k = x được gọi là logarit cơ số a của x. Kí hiệu: k = \\log_a(x).","Ta có thể hình dung k = \\log_a(x) là số lần phải chia x cho a cho tới khi x = 1.","Ví dụ, ta có: 6 = \\log_2(64): 64 \\rightarrow 32 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1","Số 64 cần 6 lần chia cho 2 để bằng 1, bằng giá trị của \\log_2(64). Một số công thức của logarit:","Tích: \\log_a(xy) = \\log_a(x) + \\log_a(y)","Thương: \\log_a(\\frac{x}{y}) = \\log_a(x) - \\log_a(y)","Lũy thừa: \\log_a(x^n) = n \\times \\log_a(x) Logarit cơ số b của một số x có thể được xác định bằng công thức: \\log_b(x) = \\frac{\\log_a(x)}{\\log_a(b)}.","Logarit tự nhiên \\ln(x) là logarit cơ số e \\approx 2.71828. Trong tin học, khi có hàm \\log không có chú thích gì thêm, hãy mặc định nó là logarit cơ số 2."]}],[{"l":"Độ phức tạp thuật toán","p":["Khi viết chương trình giải quyết các bài toán, ta cần phải tuân thủ những giới hạn mà bài toán đặt ra về thời gian và bộ nhớ. Vậy làm sao để biết được chương trình của ta chạy trong bao lâu, và sử dụng bao nhiêu bộ nhớ? Để ước tính thời gian và bộ nhớ mà một thuật toán sử dụng, ta cần phải biết về độ phức tạp của thuật toán."]},{"l":"Giới thiệu","p":["Các máy tính khác nhau sẽ có tốc độ xử lí khác nhau - một số máy thì chạy nhanh, một số khác thì chậm, còn lại chạy vừa vừa. Có những trường hợp như 2 anh A và B cùng chạy một chương trình máy tính, cùng một thuật toán, nhưng máy của anh A lại chạy trong 6 giây, còn máy của anh B lại mất tới 9 giây. 6 hay 9 giây? Để có được một sự thống nhất trong việc xác định độ hiệu quả của một thuật toán, ta thực hiện việc tính độ phức tạp của thuật toán ấy."]},{"l":"Độ phức tạp thời gian","p":["Độ phức tạp thời gian của một thuật toán sẽ ước tính thời gian chạy của một thuật toán dựa vào kích thức dữ liệu nhập để biết được nếu độ hiệu quả của thuật toán. Độ phức tạp thời gian được biểu diễn dưới dạng Big-O với kí hiệu O(...), ta thay thế 3 dấu chấm với kết quả của việc tính độ phức tạp thời gian. Thông thường, n dùng để tượng trưng cho kích thước dữ liệu nhập. Vì thời gian thực hiện thuật toán có thể thay đổi tùy vào những giá trị khác nhau có trong các dữ liệu nhập có cùng kích thước n, ta quan tâm nhiều nhất là trường hợp tệ nhất của thuật toán."]},{"l":"Cách tính độ phức tạp thời gian","p":["Các câu lệnh đơn giản như phép cộng, trừ,... các số nguyên thường không đáng kể, có độ phức tạp O(1).","Một vòng lặp có độ phức tạp O(n).","Hai vòng lặp lồng nhau có độ phức tạp O(n^{2}).","Từ đây, k vòng lặp lồng nhau có độ phức tạp thời gian là O(n^k). Việc tính độ phức tạp thời gian chỉ thể hiện qua độ lớn của đầu vào và bỏ qua các hằng số, nên các vòng lặp như:","Lặp với số lần lần lượt là 5 \\times n, $\\left\\lceil \\frac{2} \\right\\rceil $ vẫn có độ phức tạp thời gian là O(n). Nếu chương trình có nhiều giai đoạn với các độ phức tạp khác nhau, ta sẽ chọn giai đoạn có độ phức tạp chậm nhất trong tất cả các giai đoạn làm độ phức tạp thời gian của cả thuật toán.","Chương trình trên có 2 giai đoạn với độ phức tạp lần lượt là O(n) và O(n^{2}). Vậy độ phức tạp thời gian của chương trình là O(n^2) + O(n) = O(n^{2}). Nên nhớ rằng độ phức tạp thời gian chỉ ước tính thời gian của thuật toán dựa trên kích thước đầu vào nên các chương trình như:","Sẽ có độ phức tạp thời gian là O(1), mặc dù đang thực hiện một vòng lặp."]},{"l":"Các yếu tố khác","p":["Việc tính độ phức tạp thời gian không chỉ có mỗi 1 giá trị mà còn có thể nhiều hơn. Code dưới đây có độ phức tạp thời gian là O(nm)."]},{"l":"Đệ quy","p":["Độ phức tạp của một hàm đệ quy được tính bằng số lần gọi đệ quy và độ phức tạp của mỗi lần gọi. Hàm dưới đây sẽ in ra các số từ 1 đến n:","Dễ thấy hàm này được gọi n lần và mỗi lần gọi có độ phức tạp thời gian là O(1). Từ đó ta suy ra được độ phức tạp thời gian của hàm sẽ là O(n). Xét hàm dưới đây:","Hàm f(n) sẽ được gọi 1 lần, f(n - 1) được gọi 2 lần, ..., f(1) được gọi 2^{n - 1} lần. Từ đó, độ phức tạp thời gian của thuật toán sẽ là:","1 + 2 + 4 + ... + 2^{n - 1} = 2^n - 1 = O(2^n)"]},{"l":"Một số tên gọi của các độ phức tạp phổ biến","p":["Bậc ba","Bậc hai","Constant","Cubic","Độ phức tạp","Exponential","Hàm mũ","Hằng số","Linear","logarithmic","O(\\log{n})","O(\\sqrt{n})","O(1)","O(C^n)","O(n)","O(n^2)","O(n^3)","O(n^k)","Polynomial","Quadratic","Square root","Tên gọi tiếng anh","Tên gọi tiếng việt","Tuyến tính"]},{"l":"Ước tính độ phức tạp thời gian","p":["Ta có thể ước tính độ phức tạp thời gian để xác định xem thuật toán của ta có thể chạy được trong giới hạn thời gian hay không. Máy chấm thường sẽ thực hiện 10^8 phép tính/giây. Bài cho ta giới hạn 1 giây và ta chạy một thuật toán O(n^2) với n = 10^5 thì máy chấm sẽ phải xử lí ít nhất (10^5)^{2}= 10^{10} phép tính và thời gian chạy sẽ là \\frac{10^{10}}{10^8} = 100 giây. Vậy là chương trình của ta đã chạy quá thời gian và nhận về lỗi TLE. Khi biết được giá trị n, ta có thể ước tính được độ phức tạp của thuật toán ta cần áp dụng:|Giá trị của n|Ước tính độ phức tạp||---|---|| n \\leq 10| O(n!)|| n \\leq 20| O(2^n)|| n \\leq 100| O(n^4)|| n \\leq 500| O(n^3)|| n \\leq 5000| O(n^2)|| n \\leq 5 \\times 10^5| O(n\\sqrt{n})|| n \\leq 10^6| O(n \\log{n}) hoặc O(n)|| n là số lớn| O(1) hoặc O(\\log{n})|"]},{"l":"Độ phức tạp bộ nhớ","p":["Tương tự độ phức tạp thời gian, độ phức tạp bộ nhớ ước tính lượng bộ nhớ được sử dụng khi thực hiện thuật toán. Những gì được nói ở phần độ phức tạp bộ nhớ cũng tương tự với độ phức tạp thời gian: các kiểu dữ liệu cơ bản(trừ string) có độ phức tạp O(1), và một mảng n phần tử có độ phức tạp bộ nhớ O(n). Không giống với độ phức tạp thời gian, độ phức tạp bộ nhớ thường khá \"thoáng\", với giới hạn bộ nhớ của bài thường không quá khắt khe, thế nên ta không cần tìm hiểu quá chi tiết như độ phức tạp thời gian."]}],[{"l":"Thao tác xử lý bit"},{"l":"Số nhị phân","p":["Một số nhị phân là một số được biểu diễn trong hệ cơ số 2- các được biểu diễn bằng 2 chữ số 0 và 1. Trong lập trình, kiểu dữ liệu lưu các số nguyên có n bit được dùng để lưu một dãy số nhị phân chứa n chữ số. Trong C++, int là một kiểu dữ liệu lưu các số nguyên có 32 bit, còn long long là 64 bit. Ta lấy ví dụ số 193 lưu trên kiểu dữ liệu int sẽ có dãy nhị phân: 00000000000000000000000011000001 Để tìm giá trị của một dãy số nhị phân (b_k b_{k-1}... b_1 b_0), ta có công thức:","b_k \\times 2^k + b_{k - 1} \\times 2^{k - 1} + ... + b_{1} \\times 2^{1} + b_{0} \\times 2^{0}","Ví dụ, số nhị phân 1011_2 có giá trị bằng:","1011_2 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 11","Để biểu diễn giá trị âm trên dãy số nguyên, ta sử dụng Two's complement (phần bù của 2). Khi này, giá trị của một dãy số nhị phân (b_k b_{k-1}... b_1 b_0) là:","b_k \\times {-2}^k + b_{k - 1} \\times 2^{k - 1} + ... + b_{1} \\times 2^{1} + b_{0} \\times 2^{0}","Ví dụ, ta có số -209 khi biểu diễn dưới dãy nhị phân ( 16 chữ số):","1111111100101111","Khi không áp dụng phần bù của 2, một số nguyên n bit có thể lưu các giá trị từ 0 đến 2^n - 1, tức là ta lưu các số nguyên không âm. Để lưu dạng số này trong C++ ta khai báo unsigned [int/long long/...] tên_biến;.","Khi áp dụng phần bù của 2, ta có thể lưu các giá trị trong khoảng từ {-2}^{n - 1} đến 2^{n - 1} - 1. Khi này ta có thể lưu cả giá trị các số nguyên âm. Trong C++, ta khai báo signed [int/long long/...] tên_biến, ta có thể bỏ signed.","Nếu số ta lưu giá trị lớn hơn giới hạn trên của kiểu dữ liệu, ta sẽ bị tràn số. Đối với các kiểu dữ liệu signed, số tiếp theo của 2^{n - 1} - 1 sẽ là -2^{n - 1}. Đối với unsigned thì số tiếp theo của 2^n - 1 sẽ là 0."]},{"l":"Các toán tử thao tác bit"},{"i":"toán-tử-thao-tác-and-","l":"Toán tử thao tác AND (\\land)","p":["Toán tử thao tác AND x y trả về một số có giá trị bit ở mỗi vị trí là kết quả của việc thực hiện phép lý phép toán luận lý AND với các bit của x và y ở vị trí tương ứng - nếu 2 bit đều bằng 1 thì bit có giá trị là 1, không thì bit có giá trị 0. Ví dụ:","Bản chân trị cho thao tác AND:","A","B","A \\land B","1","0"]},{"i":"toán-tử-thao-tác-or-","l":"Toán tử thao tác OR (\\lor)","p":["Toán tử thao tác OR x | y trả về một số có giá trị bit ở mỗi vị trí là kết quả của việc thực hiện phép lý phép toán luận lý OR với các bit của x và y ở vị trí tương ứng - nếu có ít nhất 1 bit trong 2 bit bằng 1 thì bit có giá trị 1, không thì bit có giá trị 0. Ví dụ:","Bản chân trị cho thao tác OR:","A","B","A \\lor B","1","0"]},{"i":"toán-tử-thao-tác-xor-","l":"Toán tử thao tác XOR (\\oplus)","p":["Toán tử thao tác XOR x ^ y trả về một số có giá trị bit ở mỗi vị trí là kết quả của việc thực hiện phép lý phép toán luận lý XOR với các bit của x và y ở vị trí tương ứng - nếu - nếu hai bit của hai số có giá trị khác nhau, bit tương ứng có giá trị 1, không thì bit có giá trị 0. Ví dụ:","Bản chân trị cho thao tác XOR:","A","B","A \\oplus B","1","0"]},{"i":"toán-tử-thao-tác-not-","l":"Toán tử thao tác NOT (\\neg)","p":["Toán tử thao tác NOT~x về một số có giá trị bit ở mỗi vị trí là kết quả của việc thực hiện phép lý phép toán luận lý NOT với các bit của x ở vị trí tương ứng - nếu bit có giá trị là 1 thì sẽ có giá trị 0 và ngược lại. Ví dụ:","Bản chân trị cho thao tác NOT:","A","\\neg A","1","0","Khi thực hiện thao tác NOT với bool, ta có để sử dụng thao tác !x để trả giá trị ngược lại của biến bool. Khi dùng ! với số nguyên như int hay long long, nó sẽ trả về 1 nếu số nguyên có giá trị 0, và trả về 0 nếu số nguyên có giá trị khác 0."]},{"i":"toán-tử-thao-tác-dịch-trái-","l":"Toán tử thao tác dịch trái (\\ll)","p":["Toán tử thao tác dịch trái a n xóa thêm n bit số 0 vào đầu dãy bit. Ví dụ:"]},{"i":"toán-tử-thao-tác-dịch-phải-","l":"Toán tử thao tác dịch phải (\\gg)","p":["Toán tử thao tác dịch phải a n xóa n bit vào đầu dãy bit. Ví dụ:"]},{"l":"Ứng dụng của các thao tác xử lý bit","p":["Ta sẽ mặc định chỉ số đầu tiên có giá trị là 0."]},{"i":"nhânchia-với-","l":"Nhân/Chia với 2^x","p":["Nếu chỉ nhân hoặc chia một số với một lũy thừa của 2, ta có thể dịch bit của số nguyên ấy. Mỗi lần dịch 1 bit sang trái sẽ tương đương với nhân số ấy với 2, mỗi lần dịch 1 bit sang phải sẽ tương đương với chia lấy phần nguyên cho 2."]},{"i":"bitmask-mảng-bit","l":"Bitmask (Mảng bit)","p":["Bitmask là một một mảng lưu các giá trị bit. Bitmask còn có thể được dùng để làm một tập hợp lưu các giá trị. Ta có thể tạo một bitmask bằng int hoặc long long tương ứng với 32 bit và 64 bit. Ví dụ:","Như ta có thể thấy, khi S = 14 thì có thể biểu thị một tập hợp có các phần tử 0, 1, 3. Dưới đây là một số thao tác của bitmask:"]},{"i":"bật-bit-thứ-","l":"Bật bit thứ i","p":["Để bật bit thứ i của S, ta sử dụng thao tác bit OR: S = S | (1 i)."]},{"i":"tắt-bit-thứ-","l":"Tắt bit thứ i","p":["Để tắt bit thứ i của S, ta sử dụng thao tác bit AND: S = S ~(1 i)."]},{"i":"đảo-bit-thứ-","l":"Đảo bit thứ i","p":["Để đảo bit thứ i của S, ta sử dụng thao tác bit XOR: S = S ^ (1 i):"]},{"i":"lấy-giá-trị-kiểm-tra-bit-thứ-","l":"Lấy giá trị, kiểm tra bit thứ i","p":["Để lấy giá trị bit thứ i của S, ta sử dụng thao tác bit AND: T = S (1 i).","Nếu T bằng 0, bit thứ i có giá trị là 0","Nếu T khác 0, hay T bằng 1 i, bit thứ i có giá trị là 1","Ngoài ra còn có các kiểm tra khác cũng sử dụng thao tác bit AND: bit thứ i có giá trị (S i) 1."]},{"i":"bật--bit-đầu-tiên","l":"Bật n bit đầu tiên","p":["Để bật n bit đầu tiên, ta có: S = (1 n) - 1.","Từ ví dụ trên, ta còn rút thêm được một ứng dụng nữa: Xác định N có phải là một lũy thừa của 2. Để làm được điều này, ta sử dụng thao tác AND: N (N - 1):","Nếu N (N - 1) bằng 0 và N khác 0, N là một lũy thừa của 2","Nếu N (N - 1) khác 0, N không là một lũy thừa của 2"]},{"l":"Tìm bit có giá trị nhỏ nhất","p":["Least significant bit (LSB) hay bit có giá trị nhỏ nhất là bit có giá trị 1 đầu tiên trong dãy nhị phân xét từ phải sang trái. Để tìm được biểu diễn giá trị của bit này, ta sử dụng thao tác AND: x -x. Nếu giá trị trả về là 0 thì không có bit nào có giá trị 1.","Để tắt LSB, ta có 2 cách: x = x - (x -x) hoặc x = x (x - 1)"]},{"l":"Duyệt các tập con của bitmask","p":["Ta có một bitmask mask và giờ đây ta muốn duyệt các tập con của nó. Ta có cách thức vô cùng đơn giản:","Nếu muốn xét cả tập hợp rỗng, ta có thể chỉnh sửa lại:"]},{"l":"Các thao tác trong tập hợp","p":["\\bar{A}","\\neg A","A \\backslash B","A \\cap B","A \\cup B","A \\land (\\neg B)","A \\land B","A \\lor B","Giao","Hiệu","Hợp","Ký hiệu cho bit","Ký hiệu cho tập hợp","Như đã nói ở trên, bitmask có thể dùng để biểu diễn tập hợp. Bảng sau sẽ cho ta thấy các thao tác của tập hợp và cách áp dụng tương ứng với bitmask sử dụng các toán tử thao tác:","Phần bù","Thao tác"]},{"i":"một-số-hàm-liên-quan-đến-bit-trong-c","l":"Một số hàm liên quan đến bit trong C++","p":["Trình biên dịch g++ cung cấp cho ta một số hàm builtin cho các thao tác bit:","__builtin_clz(x): số lượng bit 0 ở đầu số x.","__builtin_ctz(x): số lượng bit 0 ở cuối số x.","__builtin_popcount(x): số lượng bit 1 có trong số x.","__builtin_parity(x): tính chẵn lẻ của số lượng bit 1 trong số x."]},{"i":"bitset-trong-c","l":"bitset trong C++","p":["1. Không gán trá trị: khi này các bit sẽ có giá trị là 0.","2. Gán trá trị bằng số: khi này các bit sẽ có giá trị tương ứng với các bit của số tương ứng khi biểu diễn thành số nhị phân.","3. Gán trá trị bằng xâu nhị phân: khi này các bit sẽ có giá trị tương ứng với các kí tự trong xâu nhị phân.","all()","any()","Câu lệnh","count()","Đảo giá trị bit ở tất cả các vị trí hoặc một vị trí pos","Đổi giá trị bit ở tất cả các vị trí hoặc một vị trí pos thành 0","Đổi giá trị bit ở tất cả các vị trí hoặc một vị trí pos thành 1","flip(pos)","int lưu được 32 bit, long long là 64. Nếu ta muốn lưu trữ nhiều bit hơn hoặc lưu số lương bit tùy ý thì ta sử dụng bitset trong thư viện bitset.","Khai báo:","Kích thước của bitset phải cố định.","Mô tả","Một số câu lệnh của bitset:","none()","reset(pos)","set(pos)","size()","Ta có thể gán các giá trị bit ban đầu cho bitset theo nhiều cách khác nhau:","Ta còn có thể thực hiện các thao tác bit trên bitset giống như với số nguyên. Ngoài ra để truy cập bit ta có thể sử dụng thao tác []. Ví dụ:","test(pos)","to_string()","to_ullong()","to_ulong()","Trả về biểu diễn unsigned long của bitset","Trả về biểu diễn unsigned long long của bitset","Trả về biểu diễn xâu kí tự của bitset","Trả về giá trị của bit ở vị trí pos","Trả về giá trị true nếu có ít nhất 1 bit được bật","Trả về giá trị true nếu không có bit nào được bật","Trả về giá trị true nếu tất cả các bit được bật","Trả về kích thước của bitset","Trả về số lượng bit được bật"]}],[{"l":"Thuật toán sắp xếp","p":["Thuật toán sắp xếp là thuật toán tối quan trọng trong lập trình thi đấu. Thuật toán sắp xếp là nền tảng để tối ưu các thuật toán khác, khi việc thực hiện các thao tác sẽ dễ dàng hơn khi các phần tử của một danh sách đã được sắp xếp."]},{"l":"Khái niệm","p":["Một bài toán sắp xếp kinh điển sẽ được phát biểu như sau:","Cho một mảng chứa n phần tử. Hãy sắp xếp và trả về các phần tử của mảng theo thứ tự tăng dần theo giá trị.","Ví dụ ta có mảng:","[2, 5, 7, 9, 1, 4, 6, 3, 8]","Thì sau khi sắp xếp ta có mảng mới","[1, 2, 3, 4, 5, 6, 7, 8, 9]"]},{"i":"các-thuật-toán-sắp-xếp-","l":"Các thuật toán sắp xếp O(n^{2})","p":["Các thuật toán sắp xếp O(n^{2}) thường khá đơn giản - thường khá ngắn và sử dụng 2 vòng lặp lồng nhau. Ta sẽ tìm hiểu một số thuật toán sắp xếp O(n^{2}) phổ biến."]},{"i":"sắp-xếp-nổi-bọt-bubble-sort","l":"Sắp xếp nổi bọt (Bubble sort)","p":["Thuật toán sắp xếp nổi bọt hoạt động như sau: Ta xét cặp 2 phần tử liên tiếp. Nếu phần tử đứng trước lớn hơn phần tử đứng sau, hoán đổi vị trí 2 phần tử. Lặp lại cho đến khi nào không còn cặp phần tử nào có thể hoán đổi vị trí.","Minh họa bằng video: Bubble-sort with Hungarian (\"Csángó\") folk dance"]},{"i":"sắp-xếp-chọn-selection-sort","l":"Sắp xếp chọn (Selection sort)","p":["thuật toán sắp xếp chọn hoạt động như sau: với mỗi vị trí i từ 1 đến n, ta sẽ tìm số nhỏ nhất từ vị trí i đến vị trí n và hoán đổi phần tử ở vị trí i với phần tử ở vị trí số nhỏ nhất ấy. Khi này, với mỗi lần hoàn tất duyệt phần tử thứ i, ta có i phần tử nhỏ nhất đã được sắp xếp tăng dần.","Minh họa bằng video: Select-sort with Gypsy folk dance"]},{"i":"sắp-xếp-chèn-insertion-sort","l":"Sắp xếp chèn (Insertion sort)","p":["Thuật toán sắp xếp chèn sẽ lần lượt sắp xếp 1 phần tử đầu tiên, sau đó là 2 phần tử, 3 phần tử, ..., cho tới khi toàn bộ n phần tử đã được sắp xếp. Với mỗi phần tử có chỉ số i từ 2 đến n, ta tìm chỉ số của phần tử lớn nhất không lớn hơn phần tử có chỉ số i, gọi là j. Sau đó, chèn phần tử có chỉ số i vào vị trí j trong mảng.","Minh họa bằng video: Insert-sort with Romanian folk dance"]},{"i":"các-thuật-toán-sắp-xếp--1","l":"Các thuật toán sắp xếp O(n \\log{n})","p":["Thuật toán sắp xếp có thể được tối ưu xuống còn O(n \\log{n}). Ta sẽ tìm hiểu một số thuật toán sắp xếp phổ biến."]},{"i":"sắp-xếp-trộn-merge-sort","l":"Sắp xếp trộn (Merge sort)","p":["Thuật toán sắp xếp trộn (Merge sort) là một thuật toán sắp xếp áp dụng mô hình chia để trị. Mô tả thuật toán:","Nếu kích cỡ mảng là 1, kết thúc sắp xếp.","Nếu kích cỡ lớn hơn 1:","Chia đôi mảng thành 2 mảng con có kích thước \\left\\lfloor \\frac{n}{2} \\right\\rfloor và \\left\\lceil \\frac{n}{2} \\right\\rceil","Sắp xếp 2 mảng con cách đệ quy bằng merge sort","Hợp 2 mảng con lại thành một mảng đã sắp xếp Độ phức tạp của thuật toán là O(n \\log{n}).","Minh hoạ bằng ảnh: Merge Sort Minh họa bằng video: Merge-sort with Transylvanian-saxon (German) folk dance"]},{"i":"sắp-xếp-nhanh-quicksort","l":"Sắp xếp nhanh (QuickSort)","p":["Thuật toán sắp xếp nhanh là một thuật toán áp dụng mô hình chia để trị. Mặc dù độ phức tạp của thuật toán chậm nhất là O(n^{2}) thuật toán lại có độ phức tạp trung bình là O(n \\log{n}), và khi so sánh trên máy thì nhanh hơn sắp xếp trộn trong nhiều trường hợp. Mô tả thuật toán:","Nếu kích cỡ mảng là 1, kết thúc sắp xếp.","Nếu kích cỡ lớn hơn 1:","Chọn một phần tử bất kì trong mảng","Chia mảng ra thành 2 mảng con: Một mảng con chứa các số nhỏ hơn phần tử bất kì kia, một mảng con chứa các số còn lại","Sắp xếp 2 mảng con một cách đệ quy bằng quicksort","Hợp 2 con mảng con lại thành một mảng đã sắp xếp","Minh họa bằng video: Quick-sort with Hungarian (Küküllőmenti legényes) folk dance"]},{"i":"thuật-toán-sắp-xếp-nhỏ-hơn-","l":"Thuật toán sắp xếp nhỏ hơn O(n \\log {n})?","p":["Đến đây, ta tự hỏi rằng liệu có thuật toán sắp xếp nào có độ phức tạp còn nhỏ hơn O(n \\log {n}) không? Nếu như ta giới hạn ở việc so sánh giá trị giữa các phần tử thì điều này là không thể. Một mảng chứa n phần tử sẽ có tất cả n! cách sắp xếp. Với mỗi lần thực hiện một bước so sánh, số lượng cách sắp xếp giảm đi một nửa, suy ra số bước so sánh cần thực hiện để mảng được sắp xếp tăng dần sẽ là O(\\log{n!}). Sử dụng công thức Stirling, ta có: \\log{n!} = n \\log{n} - n + O(\\log{n}). Suy ra: O(\\log{n!}) = O(n\\log{n})."]},{"i":"sắp-xếp-đếm-counting-sort","l":"Sắp xếp đếm (Counting sort)","p":["Giới hạn O(n\\log{n}) ở trên sẽ chỉ áp dụng với các thuật toán so sánh các giá trị của phần tử. Nếu ta sử dụng phương pháp khác, độ phức tạp có thể thay đổi. Một trong những thuật toán sắp xếp ấy chính là sắp xếp đếm. Thuật toán sắp xếp đếm là một thuật toán sắp xếp nhanh các phần tử trong mảng, với các phần tử trong mảng là các số nguyên. Thuật toán sẽ đếm số lần xuất hiện của các giá trị có trong mảng, từ đấy sắp xếp lại các giá trị. Độ phức tạp của thuật toán sắp xếp này là O(n + k), với k là khoảng giá trị của các phần tử trong mảng. Dễ thấy, nếu k đủ nhỏ, độ phức tạp của sắp xếp nhanh sẽ hơn nhiều so với các thuật toán sắp xếp được nói ở trên."]},{"i":"thuật-toán-sắp-xếp-trong-c","l":"Thuật toán sắp xếp trong C++","p":["Việc tự tay viết cả một thuật toán sắp xếp rất tốn thời gian và rất dễ xảy ra sai sót. Vì vậy ta có thể dùng hàm sort có sẵn trong thư viện C++. Điều này không những giúp tiết kiệm thời gian viết mà còn giúp tối ưu chương trình khi những hàm trong thư viện C++ thường rất nhanh và hiệu quả. Hàm sort của C++ sẽ sắp xếp các số trong khoảng [l, r). Ví dụ: sắp xếp các phần tử trong mảng a từ vị trí 0 đến n - 1.","Hàm sort cũng có thể sắp xếp được string, với các kí tự được sắp xếp theo giá trị ASCII tương ứng:"]},{"i":"phép-so-sánh-trong-hàm-sort-c","l":"Phép so sánh trong hàm sort C++","p":["Hàm sort trong C++ yêu cầu một thao tác so sánh để có thể thực hiện việc so sánh các phần tử. Hầu hết các kiểu dữ liệu trong C++ đều có phép so sánh, ví dụ như int sắp xếp theo giá trị của nó. Kiểu dữ liệu pair sẽ được sắp xếp theo giá trị của giá trị đầu tiên trong cặp giá trị: first. Nếu có nhiều first bằng nhau thì sẽ sắp xếp theo giá trị còn lại của pair: second.","Sau khi sắp xếp xong mảng v sẽ có các phần tử được xắp xếp theo thứ tự lần lượt là (1, 2), (1, 5), (2, 3)."]},{"l":"Struct","p":["struct trong C++ mặc định không có thao tác so sánh. Vì vậy ta phải tự viết thao tác với mỗi struct mà ta muốn thực hiện việc sắp xếp bằng hàm sort. Ví dụ:","struct phanso ở ví dự trên có thao tác so sánh theo giá trị của \\frac{a}{b}:"]},{"l":"Hàm so sánh","p":["Ta có thể viết hàm so sánh để sắp xếp các phần tử: Ví dụ:","Mảng a sau khi sắp xếp xong sẽ cho ta các phần tử theo thứ tự: (1, 2), (2, 3), (4, 2)."]}],[{"l":"Thuật toán tìm kiếm nhị phân","p":["Bài toán mở đầu: Cho một mảng a chứa n phần tử phân biệt được sắp xếp tăng dần. Kiểm tra xem có tồn tại phần tử có giá trị x trong mảng hay không.","Để giải quyết bài toán này, ta có thể duyệt qua tất cả các phần tử và kiểm tra phần tử nào có giá trị bằng x, nhưng độ phức tạp thời gian sẽ là O(n). Ta có thể giải được bài toán này một cách tối ưu bằng các sử dụng thuật toán tìm kiếm nhị phân."]},{"l":"Thuật toán","p":["Ta nhận xét, vì mảng a đã được sắp xếp tăng dần, nên phần tử đứng sau luôn lớn hơn phần tử đứng trước. Giả sử phần tử a[i] nhỏ hơn x, ta có thể nhận thấy ngay được rằng mọi phần tử đứng sau a[i] đều nhỏ hơn x. Khi này, ta có thuật toán nhị phân:","Tìm giá trị của phần tử ở giữa mảng.","Xét trường hợp:","Nếu phần tử bằng x, vậy ta kết luận có phần tử có giá trị bằng x. Khi này ta kết thúc tìm kiếm nhị phân.","Nếu phần tử nhỏ hơn x, phần tử ấy và mọi phần tử đứng sau nó đều nhỏ hơn x. Loại bỏ tất cả phần tử từ đầu mảng đến phần ở giữa ấy.","Nếu phần tử ấy lớn hơn x, phần tử ấy và mọi phần tử đứng trước nó đều lớn hơn x. Loại bỏ tất cả phần tử từ cuối mảng đến phần tử ấy.","Tiếp tục thực hiện tìm kiếm nhị phân cho tới khi không còn phần tử nào để thực hiện việc tìm kiếm, khi này ta thông báo rằng mảng không tồn tại phần tử có giá trị x.","Vì mỗi lần ta tìm kiếm ta giảm đi một nửa số phần tử trong mảng, nên độ phức tạp thời gian của thuật toán tìm kiếm nhị phân sẽ là O(\\log{n})."]},{"l":"Tìm kiếm nhị phân trên hàm đơn điệu","p":["Ta có một hàm f(x) trả về một trong hai giá trị true hoặc false. Trong nhiều bài toán, ta được yêu cầu tìm giá trị x lớn nhất hoặc nhỏ nhất sao cho f(x) = true. Giống với bài toán tìm phần tử trên mảng, ta cũng có thể giải quyết dạng bài này bằng tìm kiếm nhị phân nếu hàm f(x) là một hàm đơn điệu, tức giá trị của hàm không giảm hoặc không tăng."]},{"l":"Tìm kiếm giá trị nhỏ nhất","p":["Bài toán yêu cầu tìm một giá trị k mà f(x) = false với x \\lt k và f(x) = true với x \\ge k. Ta có bảng sau:","x","0","1","...","k - 1","k","k + 1","f(x)","false","true","Từ đây, ta có thể tìm k bằng tìm kiếm nhị phân:"]},{"l":"Tìm kiếm giá trị lớn nhất","p":["Bài toán yêu cầu ta tìm một giá trị k mà f(x) = false với x \\gt k và f(x) = true với x \\le k. Ta cũng tìm k bằng tìm kiếm nhị phân giống như cách ở trên:"]},{"l":"Tìm kiếm nhị phân đáp án","p":["Ta có dạng bài toán được phát biểu như sau: Tất cả các số được chia làm số đẹp và không đẹp. Nếu x là một số đẹp thì x + 1 cũng là số đẹp. Tìm số đẹp nhỏ nhất. Dễ thấy, dạng bài toán này giống với tìm kiếm nhị phân trên hàm đơn điệu được nói ở phần trên. Chính vì thế bài toán này có thể được giải quyết bằng tìm kiếm nhị phân. Ta sẽ ứng dụng cách giải quyết này cho bài toán sau: Cho n hình chữ nhật kích thước a \\times b. Tính độ dài của hình vuông nhỏ nhất chứa tất cả n hình chữ nhật này. Ta tạo hàm f(x) trả về true nếu hình vuông cạnh x chứa được tất cả n hình chữ nhật, và false nếu không thể. Ta biết được f(x) là một hàm đơn điệu vì nếu ta có thể xếp n hình chữ nhật vào hình vuông cạnh x thì ta cũng thực hiện được với hình vuông cạnh x + 1. Ta có số lượng hình chữ nhật a \\times b nhiều nhất có thể được xếp trong hình vuông cạnh x là \\left\\lfloor \\frac{x}{a} \\right\\rfloor \\times \\left\\lfloor \\frac{x}{b} \\right\\rfloor(người đọc tự chứng minh). Từ đây ta có hàm f(x):","f(x) = 1 nếu \\left\\lfloor \\frac{x}{a} \\right\\rfloor \\times \\left\\lfloor \\frac{x}{b} \\right\\rfloor \\le n","f(x) = 0 trong trường hợp ngược lại.","Việc còn lại bây giờ là tìm kiếm nhị phân số x nhỏ nhất mà f(x) = 1."]},{"l":"Tìm kiếm nhị phân với số thực","p":["Với cách thực hiện tìm kiếm nhị phân với số thực thì ta cần có cách áp dụng thuật toán theo cách khác. Số thực khó so sánh bằng, như đã nói ở phần số thực, nếu sử dụng kiểu while (l = r), vòng lặp sẽ chạy vô tận và chương trình sẽ bị TLE. Để thực hiện việc tìm kiếm nhị phân với số thực, ta chỉnh sửa code như sau:","Thay đổi [iterator_count] để tạo sự cân bằng giữa độ chính xác kết quả và tốc độ thuật toán. Thường thì ta sẽ chọn 100 cho [iterator_count]."]},{"i":"hàm-tìm-kiếm-nhị-phân-trong-c","l":"Hàm tìm kiếm nhị phân trong C++","p":["C++ có các hàm dựa trên tìm kiếm nhị phân:","Hàm lower_bound trả về vị trí phần tử đầu tiên có giá trị lớn hơn hoặc bằng x","Hàm upper_bound trả về vị trí phần tử đầu tiên có giá trị lớn hơn x","Hàm equal_range trả về 2 vị trí lower_bound và upper_bound","Code dưới đây đếm số phần tử có giá trị bằng x.","Có thể được rút gọn bằng equal_range:","Bonus: BINARY search with FLAMENCO dance"]}],[{"l":"Kĩ thuật hai con trỏ","p":["Kĩ thuật hai con trỏ là kĩ thuật sử dụng hai con trỏ để thực hiện việc duyệt các phần tử trong mảng.","Nghe thì đơn giản nhưng đây lại là một kĩ thuật rất hữu ích với nhiều ứng dụng khác nhau. Hãy cùng tim hiểu một số ứng dụng của kĩ thuật hai con trỏ qua một số bài toán."]},{"l":"Gộp mảng","p":["Cho 2 mảng a và b được sắp xếp tăng dần. In ra một mảng c gồm các phần tử của 2 mảng kia được sắp xếp theo thứ tự tăng dần.","Cách dễ nhất để thực hiện bài toán này là một thuật toán gồm các bước như sau:","Gộp tất cả các phần tử trong 2 mảng vào một mảng mới","Sắp xếp mảng mới này","Thuật toán này đơn giản và có độ phức tạp là O(n \\log{n}). Tuy nhiên, xét đến việc các phần tử trong 2 mảng đã được sắp xếp tăng dần, ta có thể sử dụng kĩ thuật 2 con trỏ để tạo mảng c với độ phức tạp nhỏ hơn. Chương trình của ta có các bước như sau:","Khi hai phần tử đều không rỗng, tìm phần tử nhỏ nhất của 2 mảng a và b. Nếu phần tử nhỏ nhất của a nhỏ hơn của b thì thêm phần tử đấy vào mảng c là loại bỏ phần tử ấy khỏi a, nếu không thì ngược lại.","Tiếp tục thực hiện bước trên cho tới khi một trong hai mảng rỗng. Khi đấy ta thêm các phần tử còn lại của mảng còn lại vào mảng c.","Ta có ví dụ sau: a = [1, 3, 4], b = [2, 5, 6]","Vì mảng a đã được sắp xếp tăng dần nên phần tử đầu tiên của mảng a là phần tử nhỏ nhất, mảng b cũng tương tự. 1 và 2 là phần tử nhỏ nhất của 2 mảng. Vì 1 là phần tử nhỏ hơn nên ta thêm 1 vào mảng c và loại bỏ 1 khỏi mảng a.","a = [\\color{red}{\\not{1}}, 3, 4], b = [2, 5, 6], c = [1]","Vì 1 đã được xóa bỏ nên ta xét phần tử nhỏ nhất tiếp theo của mảng a là 3. Vì 2 là phần tử nhỏ hơn nên ta tiếp tục thuật toán:","a = [\\color{red}{\\not{1}}, 3, 4], b = [\\color{red}{\\not{2}}, 5, 6], c = [1, 2]","Và ta tiếp tục thuật toán cho tới khi cả 2 mảng đều rỗng. Để thực hiện thuật toán này, ta sử dụng kĩ thuật hai con trỏ. Ta tạo 2 con trỏ i và j cho 2 mảng a và b. 2 con trỏ này sẽ trỏ vào vị trí phần tử đầu tiên của 2 mảng. Mỗi lần một con trỏ trỏ đến phần tử được chọn, con trỏ đấy sẽ di chuyển đến vị trí tiếp theo trong mảng. a = [\\color{red}{\\not{1}}, \\overset{\\underset{\\downarrow}{i}}{3}, 4], b = [\\underset{\\overset{\\uparrow}{j}}{2}, 5, 6] Ta có n, m lần lượt là kích thước của mảng a và b, phần tử đầu tiên của 2 mảng có chỉ số 1. Mảng nào có con trỏ trỏ ra ngoài mảng thì ta sẽ thêm các phần tử còn lại của mảng kia vào mảng c.","Độ phức tạp thuật toán sẽ là O(n + m)."]},{"l":"Bài toán 2SUM","p":["Bài toán 2SUM được phát biểu như sau: Cho một mảng n phần tử và một số x. Tìm cặp số có tổng giá trị bằng x hoặc thông báo rằng cặp số ấy không tồn tại.","Để giải bài toán này, ta sẽ sắp xếp các phần tử trong mảng và đặt 2 con trỏ ở hai vị trí đầu và cuối mảng. Nếu tổng của các phần tử được 2 con trỏ trỏ tới có tổng lớn hơn x, ta dịch con trỏ ở cuối mảng sang trái, nếu nhỏ hơn thì dịch con trỏ ở đầu mảng sang phải. Tiếp tục thực hiện cho tới khi tìm được cặp số thỏa mãn, hoặc khi không thể duyệt được nữa.","Ta ví dụ bằng mảng sau và một số x = 11:","[1, 2, 3, 5, 8, 9, 12, 15]","Ta để hai con trỏ ở vị trí ban đầu.","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, 2, 3, 5, 8, 9, 12, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{15}}]","Dễ thấy, 1 + 15 = 16 \\gt 11. Vì vậy, ta dịch con trỏ j sang trái.","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, 2, 3, 5, 8, 9, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{12}}, 15]","1 + 12 = 13 \\gt 11, tiếp tục dịch con trỏ j sang trái.","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, 2, 3, 5, 8, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{9}}, 12, 15]","1 + 9 = 10 \\lt 11, khi này dịch con trỏ i sang phải.","[1, \\overset{\\underset{\\downarrow}{i}}{\\color{red}{2}}, 3, 5, 8, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{9}}, 12, 15]","Khi này, $2 + 9 = 11 $, mảng tồn tại cặp số có tổng bằng x.","Độ phức tạp của thuật toán là O(n \\log{n})"]},{"l":"Tổng mảng con","p":["[\\overset{\\underset{\\downarrow}{i, j}}{\\color{red}{1}}, 4, 2, 6, 3, 7, 5]","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, \\color{red}{4}, \\color{red}{2}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{6}}, 3, 7, 5]","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, \\color{red}{4}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{2}}, 6, 3, 7, 5]","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{4}}, 2, 6, 3, 7, 5]","[1, \\overset{\\underset{\\downarrow}{i}}{\\color{red}{4}}, \\color{red}{2}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{6}}, 3, 7, 5]","[1, 4, \\overset{\\underset{\\downarrow}{i}}{\\color{red}{2}}, \\color{red}{6}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{3}}, 7, 5]","[1, 4, \\overset{\\underset{\\downarrow}{i}}{\\color{red}{2}}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{6}}, 3, 7, 5]","[1, 4, 2, 6, 3, 7, 5]","Bài toán được phát biểu như sau: Cho một mảng n phần tử nguyên dương và một số x. Tìm mảng con có tổng giá trị bằng x hoặc thông báo rằng mảng con ấy không tồn tại.","Cách giải bài toán này gần giống với bài toán 2SUM ở trên:","Đặt i, j ở vị trí 1.","Dịch i sang phải.","Dịch j sang phải.","Hai con trỏ i và j của ta sẽ được đặt tại vị trí đầu mảng.","Nếu SUM(i, j) < x, dịch j sang phải. Nếu SUM(i, j) > x, dịch i sang phải. Nếu SUM(i, j) = x, đã tìm được mảng con có tổng bằng x.","Nhận xét","Sau thao tác","SUM(1, 1) = 1 < 11","SUM(1, 2) = 5 < 11","SUM(1, 3) = 7 < 11","SUM(1, 4) = 13 > 11","SUM(2, 4) = 12 > 11","SUM(3, 4) = 8 < 11","SUM(3, 5) = 11","Ta có SUM(l, r) là tổng giá trị các phần tử a_l, a_{l + 1},..., a_{r - 1}, a_{r}.","Ta ví dụ bằng mảng sau và một số x = 11:","Thao tác","Tồn tại mảng con có tổng bằng x, kết thúc thuật toán."]}]]
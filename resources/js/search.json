[[{"l":"hello bro","p":["need someone to write an introduction for the page"]}],[{"l":"Giới thiệu về lập trình thi đấu","p":["Rất cảm ơn SmolLemon, một thành viên của ChuyentinORZ, đã contribute cho ChuyentinORZ Wiki! Các bạn có thể xem repo gốc tại đây. SmolBook is licensed under CC-BY-SA 4.0","Lập trình thi đấu, tên tiếng anh là competitive programming, về cơ bản là một bộ môn thể thao, nơi thí sinh viết nên các chương trình máy tính để giải quyết các bài toán."]},{"l":"Tổng quan","p":["Việc giải một bài toán về lập trình thi đấu sẽ bao gồm 2 bước chính: Thiết kế thuật toán và cài đặt thuật toán.","Việc thiết kế thuật toán sẽ yêu cầu ta thiết kế một thuật toán phù hợp để giải quyết bài toán. Nó yêu cầu ta phải có kĩ năng tư duy giải quyết vấn đề và cả tư duy toán học. Thuật toán cần phải nhanh và hiệu quả để có thể giải quyết được bài toán.","Thông thường, các bài toán thường sẽ liên quan đến những chủ đề khác nhau: tổ hợp, lí thuyết số, lí thuyết đồ thị, lí thuyết trò chơi, xử lí xâu, cấu trúc dữ liệu,... và việc áp dụng những kiến thức này cộng thêm với các hướng giải quyết mới sẽ giúp ta thiết kế được một thuật toán hiệu quả.","Việc cài đặt thuật toán là quá trình thực hiện hóa thuật toán mà ta đã nghĩ ra. Sự hiểu biết về ngôn ngữ lập trình và cách áp dụng nó vào việc cài đặt thuật toán mà một yêu cầu hết sức quan trọng trong quá trình giải quyết bài toán.","Các chương trình cần được viết một cách ngắn gọn và xúc tích (một chương trình dài nhất cũng chỉ tầm vài trăm dòng) bởi trong các cuộc thi lập trình, thời gian là có hạn. Đồng thời, các chương trình cũng phải thỏa mãn những giới hạn mà bài toán đề ra về thời gian thực thi chương trình và giới hạn bộ nhớ mà chương trình được phép sử dụng."]},{"l":"Một chương trình điển hình","p":["Accepted (AC)","Bài toán A + B","Bài toán cho ta 2 số A và B và yêu cầu ta tính tổng của hai số ấy. Dữ liệu nhập sẽ là 2 số A và B trên một dòng dòng và yêu cầu ta in ra tổng hai số.","Chương trình bị lỗi biên dịch.","Chương trình chạy quá thời gian quy định.","Chương trình cho ra kết quả sai.","Chương trình gặp lỗi khi chạy.","Chương trình in kết quả đúng và thỏa mãn các yêu cầu của bài.","Chương trình in ra quá nhiều dữ liệu.","Chương trình sử dụng bộ nhớ nhiều hơn quy định.","Compilation Error (CE)","Internal Error (IE)","Kết quả","Khi ta nộp chương trình, máy chấm sẽ chạy chương trình với một danh sách các dữ liệu nhập (testcase) và kiểm tra đáp án mà chương trình in ra với đáp án của mỗi testcase tương ứng. Với mỗi testcase, máy chấm sẽ trả về cho ta một trong các kết quả sau đây:","Lỗi đến từ hệ thống máy chấm.","Memory Limit Exceeded (MLE)","Một chương trình máy tính được viết ra bởi thí sinh để giải một bài toán cụ thể sẽ lấy dữ liệu nhập ( input) và xuất dữ liệu ( output) chứa đáp án đúng tương ứng.","Output Limit Exceeded (OLE)","Runtime Error (RTE)","Ta ví dụ với bài toán A cộng B:","Time Limit Exceeded (TLE)","Tùy theo thể thức mà điểm cho mỗi bài sẽ khác nhau. Có thể thức sẽ tính điểm theo số lượng testcase AC/số lượng testcase, có thể thức chỉ cho điểm khi ta AC toàn bộ các testcase.","Wrong Answer (WA)","Ý nghĩa"]},{"l":"Subtask","p":["Một số bài toán sẽ chia các testcase theo các nhóm khác nhau, giúp thí sinh giành được một phần điểm số cho bài toán. Các nhóm testcase này được gọi là subtask. Các subtask thường sẽ chứa những testcase có giới hạn nhỏ hơn giới hạn bài toán, hoặc có một số tính chất đặc biệt nào đó, hoặc cả hai."]},{"i":"vì-sao-cần-lập-trình-thi-đấu","l":"Vì sao cần lập trình thi đấu?","p":["Việc giải các bài toán và tham gia các cuộc thi lập trình thi đấu có thể giúp các thí sinh có hứng thú với các ngành liên quan đến khoa học máy tính. Những kiến thức học được từ lập trình thi đấu cũng cải thiện khả năng lập trình và tư duy logic của các lập trình viên, giúp họ có lợi thế trong công việc."]},{"l":"Các cuộc thi lập trình","p":["Có vô số cuộc thi lập trình phổ biến trên toàn quốc và quốc tế. Ta cùng điểm qua một số cuộc thi tiêu biểu."]},{"i":"kì-thi-học-sinh-giỏi-cấp-trườngthành-phốtỉnh-môn-tin-học","l":"Kì thi Học sinh giỏi cấp trường/thành phố/tỉnh (môn Tin học)","p":["Mục đích của các cuộc thi này nhằm động viên, khuyến khích học sinh và giáo viên phát huy và nâng cao năng lực của bản thân, đồng thời phát hiện và bồi dưỡng những học sinh có năng khiếu ở các môn học."]},{"i":"kỳ-thi-olympic-truyền-thống-304-môn-tin-học","l":"Kỳ thi Olympic truyền thống 30/4 (môn Tin học)","p":["Cuộc thi Olympic truyền thống 30/4 là một cuộc thi học sinh giỏi hàng năm dành cho học sinh khối 10 và 11 của khu vực phía Nam. Cuộc thi này do trường THPT Chuyên Lê Hồng Phong TPHCM sáng lập và được tổ chức lần đầu tiên vào năm 1995 với mục đích phát hiện, bồi dưỡng những học sinh có năng khiếu thuộc các khối lớp 10 và 11, chuẩn bị đội ngũ cho kỳ thi học sinh giỏi quốc gia, tạo điều kiện cho việc giao lưu học hỏi giữa các học sinh giỏi và trao đổi chuyên môn giữa các thầy cô dạy lớp chuyên của các tỉnh phía Nam[^ 1]."]},{"i":"kỳ-thi-chọn-học-sinh-sinh-giỏi-khu-vực-duyên-hải-và-đồng-bằng-bắc-bộ-môn-tin-học","l":"Kỳ thi chọn Học sinh sinh giỏi khu vực Duyên Hải và đồng bằng Bắc Bộ (môn Tin học)","p":["Kỳ thi do Hội các trường THPT chuyên khu vực duyên hải và đồng bằng Bắc Bộ tổ chức hằng năm. Kỳ thi là dịp phát hiện học sinh giỏi, học sinh xuất sắc các bộ môn để các trường THPT chuyên có kế hoạch lựa chọn, bồi dưỡng các em tham gia các kỳ thi học sinh giỏi quốc gia, khu vực và quốc tế. Đồng thời là dịp để đội ngũ cán bộ quản lý và giáo viên các trường THPT chuyên trao đổi, chia sẻ kinh nghiệm, nâng cao trình độ chuyên môn bồi dưỡng môn chuyên và học sinh giỏi[^ 2]."]},{"i":"kì-thi-chọn-học-sinh-giỏi-quốc-gia-môn-tin-học","l":"Kì thi chọn Học sinh giỏi Quốc gia (môn Tin học)","p":["Kỳ thi chọn học sinh giỏi quốc gia trung học phổ thông(viết tắt là Kỳ thi HSGQG) là kỳ thi chọn học sinh giỏi cấp quốc gia dành cho học sinh bậc trung học phổ thông do Bộ Giáo dục và Đào tạo tổ chức vào khoảng từ tháng 12 đến tháng 1 hằng năm. Những học sinh đạt điểm cao nhất trong kỳ thi này ở một vài bộ môn được Bộ Giáo dục và Đào tạo triệu tập tại Hà Nội, Việt Nam để tham gia kỳ thi chọn các học sinh vào đội tuyển Quốc gia Việt Nam tham dự các cuộc thi Olympic khu vực và quốc tế[^ 3].","Ở bộ môn tin học, cuộc thi có tên gọi không chính thức là VOI - Vietnamese Olympiad in Informatics."]},{"l":"Hội thi Tin học trẻ các cấp","p":["Hội thi Tin học trẻ là kì thi tin học thường niên dành cho các học sinh các cấp. Đây là sân chơi uy tín trong lĩnh vực tin học, do Trung ương Đoàn, Bộ Khoa học và Công nghệ, Bộ Giáo dục và Đào tạo, Bộ Thông tin và Truyền thông và Hội Tin học Việt Nam phối hợp tổ chức thường niên từ năm 1995."]},{"i":"olympic-tin-học-quốc-tế-ioi","l":"Olympic Tin học Quốc tế (IOI)","p":["Olympic Tin học Quốc tế( International Olympiad in Informatics - IOI) là một cuộc thi quốc tế lập trình thi đấu thường niên dành cho học sinh trung học (cấp 2 và 3). Cuộc thi đầu tiên được tổ chức vào năm 1989 tại Bulgaria."]},{"l":"ICPC","p":["International Collegiate Programming Contest, hay ICPC, là một cuộc thi lập trình dành cho sinh viên. Đây là cuộc thi lập trình lâu đời nhất, lớn nhất và danh tiếng nhất thế giới. Hằng năm, cuộc thi thu hút hơn 50000 thí sinh từ hơn 3000 trường đại học khác nhau trên toàn thế giới. [^ 4]","Mặc dù cuộc thi chỉ giới hạn cho các trường đại học, ở Việt Nam, ban tổ chức ICPC Việt Nam cũng tổ chức Kì thi ICPC cho các bạn học sinh THPT trên khắp cả nước."]},{"l":"Các cuộc thi online","p":["Ngoài các cuộc thi lập trình thi đấu trực tiếp, nhiều trang web được tạo ra nhằm hỗ trợ và cung cấp nhiều điều bổ ích cho các thí sinh trên toàn thế giới. Các trang như VNOJ, Codeforces, Atcoder,... là một trong những ví dụ điển hình. Các trang này tổ chức các cuộc thi online, có nhiều dạng bài phong phú, một số trang còn hỗ trợ tìm kiếm việc làm liên quan đến lập trình!","Kì thi Olympic 30/4 lần thứ XXVI năm 2021","Gần 2.000 học sinh khu vực duyên hải và đồng bằng Bắc Bộ thi chọn học sinh giỏi tại TP Hải Dương","Kỳ thi chọn HSG Quốc Gia THPT"]}],[{"l":"Chọn ngôn ngữ lập trình","p":["Ngôn ngữ lập trình C++ là một trong ngôn ngữ được sử dụng phổ biến, nếu không muốn nói là phổ biến nhất trong lập trình thi đấu. Chính vì thế, tất cả các đoạn code được viết trong Smol Book đều sẽ được viết trên C++, phiên bản C++ 14 để phù hợp với Themis [Θέμις]- Chương trình chấm bài tự động- phần mềm chấm thi chính thức của Bộ Giáo dục và Đào tạo, thường xuyên được sử dụng để chấm thi trong các kỳ thi Học sinh giỏi cấp Tỉnh, Khu vực và Quốc gia - chạy chương trình C++ với phiên bản C++ 14."]},{"i":"lập-trình-c","l":"Lập trình C++","p":["Đối với C++ nói riêng và ngôn ngữ lập trình nói chung, những kiến thức về nhập xuất dữ liệu, câu lệnh lặp, lệnh rẽ nhánh, chương trình con là quá đủ để giải quyết hầu hết các yêu cầu về cài đặt của thuật toán. Những tính năng cụ thể về ngôn ngữ lập trình ví vụ như Con trỏ, Tham chiếu,... trong C++ có thể học sau.","Một số mẹo khi lập trình C++ trong lập trình thi đấu"]},{"i":"cài-đặt-môi-trường-code-c","l":"Cài đặt môi trường code C++","p":["Để chạy chương trình code C++, bạn cần 2 phần mềm chính.","Trình biên dịch C++(Compiler)","Trình soạn thảo văn bản (Text editor)","GNU Compiler Collection (GCC) là một trình biên dịch C++ vô cùng phổ biến. Người dùng Windows có thể tải MinGW để sử dụng GCC, hoặc tải g++ thông qua package manager cho người dùng GNU+ Linux/MacOS. Một trong các IDE được sử dụng rộng rãi trong các máy thi là Code::Blocks. Trên các máy Windows, để tải về Code::Blocks, ta truy cập trang web của Code::Blocks và tải về phiên bản mingw-setup bằng 1 trong 2 đường dẫn mà trang chỉ ta đến, sau đó thực hiện việc tải Code::Blocks.","Tải về Codeblock"]},{"i":"cài-đặt-codeblocks-cho-lập-trình-thi-đấu","l":"Cài đặt Code::Blocks cho lập trình thi đấu","p":["Code::Blocks trong các máy thi thường hoặc là mới được tải về hoặc là đang sử dụng các cài đặt mặc định. Mặc định, Code::Blocks sẽ cho trình biên dịch C++ biên dịch chương trình của ta theo tiêu chuẩn C 98 (compiler tiêu chuẩn từ hơn 26 năm về trước). Để Code::Block chạy đúng chương trình của ta với tiêu chuẩn mới của C, ta thực hiện các bước sau.","Từ thanh menu, chọn Settings - Compiler.","Ở phần Select compiler chọn GNU GCC Compiler làm trình biên dịch C++.","Ở phần Compiler Flags, đánh dấu tích ở phần Have g++ follow the C++14 ISO C++ language standard [-std=c++14]","Nếu trong Code::Blocks không có ô chọn biên dịch theo tiêu chuẩn C++ 14 như trên thì ta sang phần Other compiler options và thêm -std=c++14 vào để cho kết quả tương đương.","Ngoài việc thêm flag -std=c++14 để trình biên dịch biên dịch theo tiêu chuẩn C++ 14, ta còn thêm một số flag để giúp ta trong việc lập trình:","Enable all common compiler warnings (overrides many other settings) [-Wall]","Enable extra compiler warnings [-Wextra]","Optimize even more (for speed) [-O2]","Các flag này sẽ cảnh bảo ta về một số cảnh báo khi ta chương trình (-Wall, -Wextra) và tối ưu chương trình khi chạy (-O2)."]}],[{"l":"Nhập xuất dữ liệu","p":["Trong các bài toán lập trình, bài sẽ yêu cầu ta nhập vào dữ liệu, và in ra kết quả tương ứng. Ta sẽ ví dụ về cách nhập xuất dữ liệu trong C++ thông qua các bài ví dụ sau:","Nhập hai số a và b, yêu cầu in ra tổng hai số. Input:","Output:","Một cách để nhập dữ liệu phổ biến trong C++ chính là sử dụng std::cin.","Với một đoạn thông tin nó sẽ nhập vào và kết thúc khi xuất hiện dấu cách hoặc dấu xuống dòng. Vậy nên khi dữ liệu nhập có dạng như dưới đây thì đoạn code vẫn sẽ nhập vào hai số như bình thường:","Đối với việc xuất dữ liệu, ta sử dụng std::cout.","Việc nhập xuất dữ liệu liên tục sẽ giảm hiệu suất của chương trình, dẫn đến TLE. Ta áp dụng Fast I/O để tối ưu quá trình này. Ta cũng có thể sử dụng scanf/printf của C để nhập dữ liệu. Phương pháp này tuy nhanh hơn so với C++(lúc chưa có Fast I/O), nhưng lại khó dùng hơn một chút. Dưới đây là đoạn code sử dụng scanf/printf:","Ta có thể sử dụng lẫn lộn cả hai cách nhập trong chương trình. Lưu ý rằng khi sử dụng Fast I/O thì không nên làm điều này.","Đối với những bài yêu cầu đọc/ghi dữ liệu vào file, ta có thể làm điều này một cách đơn giản bằng cách sử dụng freopen:"]},{"l":"Một số yêu cầu đặc biệt cho mỗi bài"},{"l":"Nhập nhiều số với số lượng không xác định","p":["Đối với các bài có số lượng dữ liệu nhập không xác định, ta có thể viết code như sau:"]},{"l":"Nhập xâu trên một dòng","p":["Giả sử đề yêu cầu ta nhập một xâu có trên một hàng, ví dụ như:","Và ta viết dòng lệnh:","Xâu s của ta sẽ chỉ lưu abc thay vì abc def như ta mong muốn. Đấy là bởi vì cin sẽ chỉ nhập các kí tự liên tiếp cho tới khi có dấu cách, xuống dòng hoặc đến cuối file. Để có thể nhập toàn bộ kí tự có trên một dòng, ta dùng lệnh getline:"]},{"l":"Nhập nhiều số với số lượng không xác định trên nhiều dòng","p":["Đây là kết hợp giữa hai dạng trên. Ta có bài toán yêu cầu ta tính tổng các số trên mỗi hàng với số lượng không xác định.","Các dòng 1, 2, 3 lần lượt có tổng là 10, 3570 và 223. Để giải quyết bài toán này, ta sử dụng stringstream:"]}],[{"l":"Các kiểu dữ liệu","p":["-2 15 đến -2 15- 1","-2 31 đến 2 31- 1","-2 63 đến 2 63- 1","-2 7 đến 2 7- 1","≈ -1.7 x 10 308 đến ≈ 1.7 x 10 308","≈ -3,4 x 10 38 đến ≈ 3.4 x 10 38","1","2","4","8","bool","char","Dãy giá trị","double","float","Giá trị đúng/sai","int","Kí tự","Kích cỡ (bytes)","Loại dữ liệu","long long","Ở C++ và nhiều ngôn ngữ lập trình ta sẽ bắt gặp các kiểu dữ liệu được biểu diễn ở dạng nhị phân như sau:","short int","Số nguyên 16 bit","Số nguyên 32 bit","Số nguyên 64 bit","Số thực độ chính xác đơn","Số thực độ chính xác kép","Tên dữ liệu","true hoặc false(0 hoặc 1)"]},{"l":"Số nguyên","p":["int, short int, long long dùng để lưu số nguyên. Các kiểu dữ liệu này có thể lưu các số nguyên không dấu(lưu các số nguyên không âm), hoặc có dấu(có thể lưu các số nguyên âm). Để lưu các số nguyên không dấu, ta viết thêm unsigned ở đầu kiểu dữ liệu. VD:","Khi lưu các số nguyên có dấu ta không cần viết signed ở đầu kiểu dữ liệu.","Trong C++, phép % dùng để lấy phần dư của một số. Khi dùng phép % với số âm thì kết quả sẽ là \\(0\\) hoặc là một số âm. Nếu tìm modulo của một số âm bằng phép % thì ta thực hiện: ((a % b) + b) % b."]},{"l":"Số thực","p":["float, double dùng để lưu các số thực. 2 cách lưu trữ số này chỉ lưu các số thập phân chính xác một phần: float có thể lưu chính xác đến khoảng 7 số sau dấu chấm phẩn, double gấp đôi: 14 đến 15 số. Ta không nên so sánh 2 số thực bằng kí tự ==. Nếu ta chạy:","Thì nó sẽ in False thay vì True. Các bài tập yêu cầu in số thực sẽ chấp nhận kết quả chương trình của bạn nếu chệnh lệnh của đáp án của bạn và đáp án của bài nằm trong khoảng yêu cầu ví dụ như 10 9.","Nếu output là x và đáp án của test là y thì chênh lênh sẽ là |x-y|. Các biến số thực vẫn có thể lưu chính xác nếu nó được yêu cầu lưu các số nguyên."]},{"l":"Boolean","p":["bool dùng để lưu 2 giá trị True/False (1/0). Bool lại dùng đến 8 bit để lưu true/false trong khi có thể dùng 1 bit để làm điều tương tự. Ta có thể dùng bitset để có thể tối ưu bộ nhớ."]},{"l":"Kí tự","p":["char lưu kí tự theo bộ mã ASCII. Ta có thể chuyển từ kí tự sang số bằng cách dùng câu lệnh int([kí_tự]), hoặc chuyển một số sang một kí tự bằng char([mã số]). Mã số của các kí tự quen thuộc trong ASCII:","Mã số của các kí tự từ 1 đến 10 là từ 48 đến 57.","Mã số của các kí tự từ a đến z là từ 97 đến 122.","Mã số của các kí tự từ A đến Z là từ 65 đến 90.","Ta có thể chuyển từ kí tự in thường sang in hoa và ngược lại bằng cách trừ hoặc cộng 32."]},{"l":"Xâu kí tự","p":["string là một chuối kí tự chứa các giá trị char."]}],[{"i":"mẹo-lập-trình-thi-đấu-c","l":"Mẹo lập trình thi đấu C++","p":["Dưới đây là một số mẹo cho C++ trong lập trình thi đấu."]},{"i":"fast-io","l":"Fast I/O","p":["Trong hầu hết các bài nộp C++, ta thường bắt gặp 2 dòng lệnh phổ biến ở đầu hàm main:","2 câu lệnh này giúp tăng tốc chương trình bằng cách thay đổi cách nhập xuất của nó.","ios_base::sync_with_stdio(false) tắt đồng bộ giữa cách nhập xuất của C và C++. Tính năng này giúp ta có thể sử dụng linh hoạt giữa hai cách nhập xuất khác nhau. Khi tắt tính năng này, chương trình của ta sẽ chạy nhanh hơn nếu bài toán yêu cầu nhập xuất dữ liệu nhiều lần. Lưu ý rằng nếu tắt đồng bộ thì không nên sử dụng đồng thời 2 cách nhập xuất.","cin.tie(NULL) tắt đồng bộ giữa cin và cout. tie() được dùng để đảm bảo tất cả các dữ liệu của cout sẽ được xuất ra màn hình trước khi thực hiện cin nhập dữ liệu. Điều này sẽ giúp ích cho các chương trình cần sự tương tác giữa người và chương trình, hoặc chương trình và chương trình - thứ mà ngoài dạng bài toán tương tác ra thì không cần thiết trong lập trình thi đấu. Việc tương tác này sẽ chương trình của ta sẽ chạy chậm đi. Ta tắt tính năng này để gia tăng tốc độ chương trình."]},{"i":"sử-dụng-n-thay-thế-cho-endl","l":"Sử dụng '\\n' thay thế cho endl","p":["Trong lập trình thi đấu, sẽ tốt hơn nếu ta sử dụng '\\n' để xuống dòng thay vì sử dụng endl. Ta có thể hiểu endl giống như khi ta viết '\\n' flush. flush là thao tác đẩy dữ liệu từ bộ đệm đầu ra (output buffer) ra thiết bị đầu ra. Nói cách khác, nó đảm bảo rằng tất cả dữ liệu đang chờ trong bộ đệm sẽ được ghi ra màn hình. Khi flush thường xuyên sẽ giảm hiệu suất của ta, việc dùng'\\n' để xuống dòng trong các chương trình sẽ cho ta tốc độ chạy code nhanh hơn so với việc sử dụng endl."]},{"l":"Rút gọn code"},{"l":"Type name","p":["Ta có thể dùng typedef để rút gọn chương trình của ta. VD:","Sẽ giúp làm ngắn code:","thành:"]},{"l":"Macros","p":["Macro thay đổi kí tự hoặc xâu kí tự trong mã (code) khi biên dịch chương trình. Trong C++ macro được định nghĩa bằng #define {Tên_macro} {macro}. VD:"]},{"l":"Xuống dòng","p":["Dưới đây là một đoạn của một chương trình in ra các giá trị của một mảng \\(2\\) chiều kích thước n * m:","Thay vì phải in thêm một câu lệnh cout sau mỗi lần in xong một hàng, ta có cách viết khác:","Dòng lệnh này có ý nghĩa: \\n là một xâu kí tự, trong khi ta chưa duyệt đến phần tử cuối cùng, điều kiện j m thỏa mãn, chương trình in ra kí tự vị trí 1 của xâu: ' '- dấu cách. Khi đã duyệt đến phần tử cuối cùng, điều kiện j m không thỏa mãn, chương trình in ra kí tự vị trí 0 của xâu: '\\n'- xuống dòng."]},{"l":"Viết số lớn","p":["Sẽ có nhiều bài yêu cầu ta phải tạo một mảng lớn (như 10 6 chẳng hạn), nhiều người có thể sẽ viết một mảng a và số 10 6 cộng thêm một số nhỏ như 10: a[1000010]. Kiểu viết này tuy không sai nhưng rất dễ xảy ra lỗi.","Đồng thời, khi sửa lại kích thước mảng cũng rất khó khăn khi ta phải sửa lại tất cả các số ấy. Nếu ta muốn đổi kích thước của các mảng ví dụ trên thì ta viết lại 6 lần! Ta tạo một hằng số N tượng trưng cho kích thước của mảng. Ta cho N = 1e6 + 10 với giá trị bằng 1000010, vừa dễ nhìn vừa khó mắc lỗi, đồng thời cũng dễ sửa hơn.","Chữ e(hoặc E) trong đoạn code là E notation. Khi viết mEn sẽ có giá trị: m × n 10. VD:","1e6 = 10^6 = 1000000","2e5 = 2 * 10^5 = 200000"]},{"l":"Câu lệnh rẽ nhánh trong một dòng","p":["Có những lần bạn phải gán giá trị theo từng trường hợp:","Ta có thể rút gọn lại thành:"]},{"l":"For auto","p":["Mẹo chỉ áp dụng với tiêu chuẩn C++ 17.","Giả sử ta có một vector chứa pair, và ta muốn in ra các giá trị của từng pair trong vector, ta làm như sau:","Thay vào đó, ta có thể viết theo cách khác:"]},{"i":"khai-báo-hàm-ở-dưới-hàm-main","l":"Khai báo hàm ở dưới hàm main()","p":["Xin nói trước rằng đây không hẳn là một mẹo và nói đúng hơn thì nó là một sở thích cá nhân khi viết code lập trình thi đấu của tác giả.","Các chương trình C++ khi khai báo các chương trình con thường sẽ viết như sau:","Ta cũng có thể khai báo theo cách khác:","Tại sao lại khai báo hàm dưới hàm main()? Ta có một số lợi ích khi khai báo hàm theo cách này: Lợi ích 1: Dễ phân tích code. Với cách viết này, ta có thể phân tích code từ trên xuống một cách dễ dàng: Ta biết được các hàm có trong chương trình ở ngay đầu chương trình một cách ngắn gọn (mỗi dòng 1 hàm), biết được các hàm được sử dụng như thế nào trong hàm main() ngay sau đó, và biết cách hoạt động của các hàm ở cuối chương trình. Còn cách viết ở trên thì ta phải lướt lên lướt xuống để làm được những điều tương tự. Lợi ích 2: Không xuất hiện lỗi khi có các hàm phụ thuộc lẫn nhau. Ta có chương trình sau:","Chương trình ở trên sẽ không chạy được do hàm odd() được khai báo trước hàm even(), từ đó \"không thấy\" hàm ấy. Vẫn đề đó sẽ không tồn tại nếu ta viết theo cách sau:","Bằng cách khai báo các hàm ở dưới hàm main, ta tránh được lỗi xảy ra khi các hàm phụ thuộc lẫn nhau. Tuy nhiên, cách viết này cũng tồn tại một vài bất lợi, cụ thể là khi sửa các hàm ta phải sửa tận 2 vị trí thay vì 1."]}],[{"l":"Kiến thức toán cơ bản","p":["Toán học có vai trò quan trọng trong lập trình thi đấu. Việc bạn giỏi toán, hoặc có khá năng tư duy toán học tốt là một lợi thế so với những người khác. Ta sẽ nói về một số kiến thức cơ bản có tính ứng dụng cao trong lập trình thi đấu."]},{"l":"Công thức tính tổng","p":["Ta có công thức tính tổng của một số dãy số: Tổng của n số tự nhiên đầu tiên:","1 + 2 + ... + n = \\frac{n(n + 1)}{2}","Tổng lũy thừa của n số tự nhiên đầu tiên:","1^2 + 2^2 + ... + n^2 = \\frac{n(n + 1)(2n + 1)}{6}","Tổng của một cấp số cộng u_n với số hạng đầu u_1 và công sai d:","u_1 + u_2 + ... + u_n = \\frac{n[2u_1 + (n - 1)d]}{2} = \\frac{n(u_1 + u_n)}{2}","Tổng của một cấp số nhân u_n với số hạng đầu u_1 và công bội q \\neq 1:","u_1 + u_2 + ... + u_n = \\frac{u_1(q^n - 1)}{q - 1}","Từ đây ta có tổng của n lũy thừa đầu tiên của 2 bằng:","1 + 2 + ... + 2^{n - 1} = 2^n - 1"]},{"l":"Lý thuyết tập hợp","p":["Một tập hợp là một bộ các phần tử. Ví dụ với tập hợp X:","X = {2, 3, 5}","chứa các phần tử 2, 3, 5. Một tập hợp không chứa phần tử được gọi là tập rỗng. Kí hiệu là \\emptyset. Ta sử dụng kí hiệu \\in hoặc \\notin để biểu thị nếu phần tử có nằm trong tập hợp hay không. Ví dụ với tập hợp X ở trên, 2 thuộc tập hợp X nên ta viết 2 \\in X, 1 không thuộc tập hợp X nên ta viết 1 \\notin X.","Ta kí hiệu số lượng các phần tử trong tập X là |X|. Chẳng hạn, tập hợp X ở trên có |X| = 3 phần tử.","Một tập hợp Y mà tất cả các phần tử nằm trong Y đều nằm trong X thì ta nói tập hợp Y là con của tập hợp X. Kí hiệu Y \\subset X.","Một tập hợp X sẽ có 2^{|X|} tập con khác nhau. Đối với tập hợp X ở trên sẽ có các tập hợp con:","\\emptyset, \\\\{2\\\\}, \\\\{3\\\\}, \\\\{5\\\\}, \\\\{2, 3\\\\}, \\\\{2, 5\\\\}, \\\\{3, 5\\\\}, \\\\{2, 3, 5\\\\}","Ta có các phép toán trên tập hợp:","Giao của hai tập hợp X và Y là một tập hợp có các phần tử nằm trong cả tập X và tập Y, kí hiệu X \\cap Y. Nếu X = {1, 2, 4} và Y = {1, 4, 5} thì X \\cap Y = {1, 4}. Hợp của hai tập hợp X và Y là một tập hợp có các phần tử nằm trong một trong hai tập X và Y hoặc cả hai, kí hiệu X \\cup Y. Nếu X = {1, 2, 4} và Y = {1, 4, 5} thì X \\cup Y = {1, 2, 4, 5}. Hiệu của hai tập hợp X và Y là một tập hợp có các phần tử nằm trong tập X nhưng không nằm trong tập Y, kí hiệu X \\setminus Y. Nếu X = {1, 2, 4} và Y = {1, 4, 5} thì X \\setminus Y = {1}. Nếu Y \\subset X thì X \\setminus Y được gọi là phần bù của Y trong X, kí hiệu C_X Y. Trong toán học ta cũng có kí hiệu cho các tập hợp số.","Tập hợp các số tự nhiên: \\mathbb{N} = {0, 1, 2, ... }","Tập hợp các số nguyên: \\mathbb{Z} = {..., -2, -1, 0, 1, 2, ... }","Tập hợp các số hữu tỉ: \\mathbb{Q} = {0, 7, \\frac{1}{2} ... }","Tập hợp các số vô tỉ: \\mathbb{R} = {\\pi, e, \\sqrt{2} ... }","Mối quan hệ giữa các tập hợp số: \\mathbb{N} \\subset \\mathbb{Z} \\subset \\mathbb{Q} \\subset \\mathbb{R}"]},{"l":"Logarit","p":["Định nghĩa của logarit được phát biểu như sau:","Cho a là một số thực khác 0 và một số thực x. Số thực k để a^k = x được gọi là logarit cơ số a của x. Kí hiệu: k = \\log_a(x).","Ta có thể hình dung k = \\log_a(x) là số lần phải chia x cho a cho tới khi x = 1.","Ví dụ, ta có: 6 = \\log_2(64): 64 \\rightarrow 32 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1","Số 64 cần 6 lần chia cho 2 để bằng 1, bằng giá trị của \\log_2(64). Một số công thức của logarit:","Tích: \\log_a(xy) = \\log_a(x) + \\log_a(y)","Thương: \\log_a(\\frac{x}{y}) = \\log_a(x) - \\log_a(y)","Lũy thừa: \\log_a(x^n) = n \\times \\log_a(x) Logarit cơ số b của một số x có thể được xác định bằng công thức: \\log_b(x) = \\frac{\\log_a(x)}{\\log_a(b)}.","Logarit tự nhiên \\ln(x) là logarit cơ số e \\approx 2.71828. Trong tin học, khi có hàm \\log không có chú thích gì thêm, hãy mặc định nó là logarit cơ số 2."]}],[{"l":"Độ phức tạp thuật toán","p":["Khi viết chương trình giải quyết các bài toán, ta cần phải tuân thủ những giới hạn mà bài toán đặt ra về thời gian và bộ nhớ. Vậy làm sao để biết được chương trình của ta chạy trong bao lâu, và sử dụng bao nhiêu bộ nhớ? Để ước tính thời gian và bộ nhớ mà một thuật toán sử dụng, ta cần phải biết về độ phức tạp của thuật toán."]},{"l":"Giới thiệu","p":["Các máy tính khác nhau sẽ có tốc độ xử lí khác nhau - một số máy thì chạy nhanh, một số khác thì chậm, còn lại chạy vừa vừa. Có những trường hợp như 2 anh A và B cùng chạy một chương trình máy tính, cùng một thuật toán, nhưng máy của anh A lại chạy trong 6 giây, còn máy của anh B lại mất tới 9 giây. 6 hay 9 giây? Để có được một sự thống nhất trong việc xác định độ hiệu quả của một thuật toán, ta thực hiện việc tính độ phức tạp của thuật toán ấy."]},{"l":"Độ phức tạp thời gian","p":["Độ phức tạp thời gian của một thuật toán sẽ ước tính thời gian chạy của một thuật toán dựa vào kích thức dữ liệu nhập để biết được nếu độ hiệu quả của thuật toán. Độ phức tạp thời gian được biểu diễn dưới dạng Big-O với kí hiệu O(...), ta thay thế 3 dấu chấm với kết quả của việc tính độ phức tạp thời gian. Thông thường, n dùng để tượng trưng cho kích thước dữ liệu nhập. Vì thời gian thực hiện thuật toán có thể thay đổi tùy vào những giá trị khác nhau có trong các dữ liệu nhập có cùng kích thước n, ta quan tâm nhiều nhất là trường hợp tệ nhất của thuật toán."]},{"l":"Cách tính độ phức tạp thời gian","p":["Các câu lệnh đơn giản như phép cộng, trừ,... các số nguyên thường không đáng kể, có độ phức tạp O(1).","Một vòng lặp có độ phức tạp O(n).","Hai vòng lặp lồng nhau có độ phức tạp O(n^{2}).","Từ đây, k vòng lặp lồng nhau có độ phức tạp thời gian là O(n^k). Việc tính độ phức tạp thời gian chỉ thể hiện qua độ lớn của đầu vào và bỏ qua các hằng số, nên các vòng lặp như:","Lặp với số lần lần lượt là 5 \\times n, $\\left\\lceil \\frac{2} \\right\\rceil $ vẫn có độ phức tạp thời gian là O(n). Nếu chương trình có nhiều giai đoạn với các độ phức tạp khác nhau, ta sẽ chọn giai đoạn có độ phức tạp chậm nhất trong tất cả các giai đoạn làm độ phức tạp thời gian của cả thuật toán.","Chương trình trên có 2 giai đoạn với độ phức tạp lần lượt là O(n) và O(n^{2}). Vậy độ phức tạp thời gian của chương trình là O(n^2) + O(n) = O(n^{2}). Nên nhớ rằng độ phức tạp thời gian chỉ ước tính thời gian của thuật toán dựa trên kích thước đầu vào nên các chương trình như:","Sẽ có độ phức tạp thời gian là O(1), mặc dù đang thực hiện một vòng lặp."]},{"l":"Các yếu tố khác","p":["Việc tính độ phức tạp thời gian không chỉ có mỗi 1 giá trị mà còn có thể nhiều hơn. Code dưới đây có độ phức tạp thời gian là O(nm)."]},{"l":"Đệ quy","p":["Độ phức tạp của một hàm đệ quy được tính bằng số lần gọi đệ quy và độ phức tạp của mỗi lần gọi. Hàm dưới đây sẽ in ra các số từ 1 đến n:","Dễ thấy hàm này được gọi n lần và mỗi lần gọi có độ phức tạp thời gian là O(1). Từ đó ta suy ra được độ phức tạp thời gian của hàm sẽ là O(n). Xét hàm dưới đây:","Hàm f(n) sẽ được gọi 1 lần, f(n - 1) được gọi 2 lần, ..., f(1) được gọi 2^{n - 1} lần. Từ đó, độ phức tạp thời gian của thuật toán sẽ là:","1 + 2 + 4 + ... + 2^{n - 1} = 2^n - 1 = O(2^n)"]},{"l":"Một số tên gọi của các độ phức tạp phổ biến","p":["Bậc ba","Bậc hai","Constant","Cubic","Độ phức tạp","Exponential","Hàm mũ","Hằng số","Linear","logarithmic","O(\\log{n})","O(\\sqrt{n})","O(1)","O(C^n)","O(n)","O(n^2)","O(n^3)","O(n^k)","Polynomial","Quadratic","Square root","Tên gọi tiếng anh","Tên gọi tiếng việt","Tuyến tính"]},{"l":"Ước tính độ phức tạp thời gian","p":["Ta có thể ước tính độ phức tạp thời gian để xác định xem thuật toán của ta có thể chạy được trong giới hạn thời gian hay không. Máy chấm thường sẽ thực hiện 10^8 phép tính/giây. Bài cho ta giới hạn 1 giây và ta chạy một thuật toán O(n^2) với n = 10^5 thì máy chấm sẽ phải xử lí ít nhất (10^5)^{2}= 10^{10} phép tính và thời gian chạy sẽ là \\frac{10^{10}}{10^8} = 100 giây. Vậy là chương trình của ta đã chạy quá thời gian và nhận về lỗi TLE. Khi biết được giá trị n, ta có thể ước tính được độ phức tạp của thuật toán ta cần áp dụng:|Giá trị của n|Ước tính độ phức tạp||---|---|| n \\leq 10| O(n!)|| n \\leq 20| O(2^n)|| n \\leq 100| O(n^4)|| n \\leq 500| O(n^3)|| n \\leq 5000| O(n^2)|| n \\leq 5 \\times 10^5| O(n\\sqrt{n})|| n \\leq 10^6| O(n \\log{n}) hoặc O(n)|| n là số lớn| O(1) hoặc O(\\log{n})|"]},{"l":"Độ phức tạp bộ nhớ","p":["Tương tự độ phức tạp thời gian, độ phức tạp bộ nhớ ước tính lượng bộ nhớ được sử dụng khi thực hiện thuật toán. Những gì được nói ở phần độ phức tạp bộ nhớ cũng tương tự với độ phức tạp thời gian: các kiểu dữ liệu cơ bản(trừ string) có độ phức tạp O(1), và một mảng n phần tử có độ phức tạp bộ nhớ O(n). Không giống với độ phức tạp thời gian, độ phức tạp bộ nhớ thường khá \"thoáng\", với giới hạn bộ nhớ của bài thường không quá khắt khe, thế nên ta không cần tìm hiểu quá chi tiết như độ phức tạp thời gian."]}],[{"l":"Thao tác xử lý bit"},{"l":"Số nhị phân","p":["Một số nhị phân là một số được biểu diễn trong hệ cơ số 2- các được biểu diễn bằng 2 chữ số 0 và 1. Trong lập trình, kiểu dữ liệu lưu các số nguyên có n bit được dùng để lưu một dãy số nhị phân chứa n chữ số. Trong C++, int là một kiểu dữ liệu lưu các số nguyên có 32 bit, còn long long là 64 bit. Ta lấy ví dụ số 193 lưu trên kiểu dữ liệu int sẽ có dãy nhị phân: 00000000000000000000000011000001 Để tìm giá trị của một dãy số nhị phân (b_k b_{k-1}... b_1 b_0), ta có công thức:","b_k \\times 2^k + b_{k - 1} \\times 2^{k - 1} + ... + b_{1} \\times 2^{1} + b_{0} \\times 2^{0}","Ví dụ, số nhị phân 1011_2 có giá trị bằng:","1011_2 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 11","Để biểu diễn giá trị âm trên dãy số nguyên, ta sử dụng Two's complement (phần bù của 2). Khi này, giá trị của một dãy số nhị phân (b_k b_{k-1}... b_1 b_0) là:","b_k \\times {-2}^k + b_{k - 1} \\times 2^{k - 1} + ... + b_{1} \\times 2^{1} + b_{0} \\times 2^{0}","Ví dụ, ta có số -209 khi biểu diễn dưới dãy nhị phân ( 16 chữ số):","1111111100101111","Khi không áp dụng phần bù của 2, một số nguyên n bit có thể lưu các giá trị từ 0 đến 2^n - 1, tức là ta lưu các số nguyên không âm. Để lưu dạng số này trong C++ ta khai báo unsigned [int/long long/...] tên_biến;.","Khi áp dụng phần bù của 2, ta có thể lưu các giá trị trong khoảng từ {-2}^{n - 1} đến 2^{n - 1} - 1. Khi này ta có thể lưu cả giá trị các số nguyên âm. Trong C++, ta khai báo signed [int/long long/...] tên_biến, ta có thể bỏ signed.","Nếu số ta lưu giá trị lớn hơn giới hạn trên của kiểu dữ liệu, ta sẽ bị tràn số. Đối với các kiểu dữ liệu signed, số tiếp theo của 2^{n - 1} - 1 sẽ là -2^{n - 1}. Đối với unsigned thì số tiếp theo của 2^n - 1 sẽ là 0."]},{"l":"Các toán tử thao tác bit"},{"i":"toán-tử-thao-tác-and-","l":"Toán tử thao tác AND (\\land)","p":["Toán tử thao tác AND x y trả về một số có giá trị bit ở mỗi vị trí là kết quả của việc thực hiện phép lý phép toán luận lý AND với các bit của x và y ở vị trí tương ứng - nếu 2 bit đều bằng 1 thì bit có giá trị là 1, không thì bit có giá trị 0. Ví dụ:","Bản chân trị cho thao tác AND:","A","B","A \\land B","1","0"]},{"i":"toán-tử-thao-tác-or-","l":"Toán tử thao tác OR (\\lor)","p":["Toán tử thao tác OR x | y trả về một số có giá trị bit ở mỗi vị trí là kết quả của việc thực hiện phép lý phép toán luận lý OR với các bit của x và y ở vị trí tương ứng - nếu có ít nhất 1 bit trong 2 bit bằng 1 thì bit có giá trị 1, không thì bit có giá trị 0. Ví dụ:","Bản chân trị cho thao tác OR:","A","B","A \\lor B","1","0"]},{"i":"toán-tử-thao-tác-xor-","l":"Toán tử thao tác XOR (\\oplus)","p":["Toán tử thao tác XOR x ^ y trả về một số có giá trị bit ở mỗi vị trí là kết quả của việc thực hiện phép lý phép toán luận lý XOR với các bit của x và y ở vị trí tương ứng - nếu - nếu hai bit của hai số có giá trị khác nhau, bit tương ứng có giá trị 1, không thì bit có giá trị 0. Ví dụ:","Bản chân trị cho thao tác XOR:","A","B","A \\oplus B","1","0"]},{"i":"toán-tử-thao-tác-not-","l":"Toán tử thao tác NOT (\\neg)","p":["Toán tử thao tác NOT~x về một số có giá trị bit ở mỗi vị trí là kết quả của việc thực hiện phép lý phép toán luận lý NOT với các bit của x ở vị trí tương ứng - nếu bit có giá trị là 1 thì sẽ có giá trị 0 và ngược lại. Ví dụ:","Bản chân trị cho thao tác NOT:","A","\\neg A","1","0","Khi thực hiện thao tác NOT với bool, ta có để sử dụng thao tác !x để trả giá trị ngược lại của biến bool. Khi dùng ! với số nguyên như int hay long long, nó sẽ trả về 1 nếu số nguyên có giá trị 0, và trả về 0 nếu số nguyên có giá trị khác 0."]},{"i":"toán-tử-thao-tác-dịch-trái-","l":"Toán tử thao tác dịch trái (\\ll)","p":["Toán tử thao tác dịch trái a n xóa thêm n bit số 0 vào đầu dãy bit. Ví dụ:"]},{"i":"toán-tử-thao-tác-dịch-phải-","l":"Toán tử thao tác dịch phải (\\gg)","p":["Toán tử thao tác dịch phải a n xóa n bit vào đầu dãy bit. Ví dụ:"]},{"l":"Ứng dụng của các thao tác xử lý bit","p":["Ta sẽ mặc định chỉ số đầu tiên có giá trị là 0."]},{"i":"nhânchia-với-","l":"Nhân/Chia với 2^x","p":["Nếu chỉ nhân hoặc chia một số với một lũy thừa của 2, ta có thể dịch bit của số nguyên ấy. Mỗi lần dịch 1 bit sang trái sẽ tương đương với nhân số ấy với 2, mỗi lần dịch 1 bit sang phải sẽ tương đương với chia lấy phần nguyên cho 2."]},{"i":"bitmask-mảng-bit","l":"Bitmask (Mảng bit)","p":["Bitmask là một một mảng lưu các giá trị bit. Bitmask còn có thể được dùng để làm một tập hợp lưu các giá trị. Ta có thể tạo một bitmask bằng int hoặc long long tương ứng với 32 bit và 64 bit. Ví dụ:","Như ta có thể thấy, khi S = 14 thì có thể biểu thị một tập hợp có các phần tử 0, 1, 3. Dưới đây là một số thao tác của bitmask:"]},{"i":"bật-bit-thứ-","l":"Bật bit thứ i","p":["Để bật bit thứ i của S, ta sử dụng thao tác bit OR: S = S | (1 i)."]},{"i":"tắt-bit-thứ-","l":"Tắt bit thứ i","p":["Để tắt bit thứ i của S, ta sử dụng thao tác bit AND: S = S ~(1 i)."]},{"i":"đảo-bit-thứ-","l":"Đảo bit thứ i","p":["Để đảo bit thứ i của S, ta sử dụng thao tác bit XOR: S = S ^ (1 i):"]},{"i":"lấy-giá-trị-kiểm-tra-bit-thứ-","l":"Lấy giá trị, kiểm tra bit thứ i","p":["Để lấy giá trị bit thứ i của S, ta sử dụng thao tác bit AND: T = S (1 i).","Nếu T bằng 0, bit thứ i có giá trị là 0","Nếu T khác 0, hay T bằng 1 i, bit thứ i có giá trị là 1","Ngoài ra còn có các kiểm tra khác cũng sử dụng thao tác bit AND: bit thứ i có giá trị (S i) 1."]},{"i":"bật--bit-đầu-tiên","l":"Bật n bit đầu tiên","p":["Để bật n bit đầu tiên, ta có: S = (1 n) - 1.","Từ ví dụ trên, ta còn rút thêm được một ứng dụng nữa: Xác định N có phải là một lũy thừa của 2. Để làm được điều này, ta sử dụng thao tác AND: N (N - 1):","Nếu N (N - 1) bằng 0 và N khác 0, N là một lũy thừa của 2","Nếu N (N - 1) khác 0, N không là một lũy thừa của 2"]},{"l":"Tìm bit có giá trị nhỏ nhất","p":["Least significant bit (LSB) hay bit có giá trị nhỏ nhất là bit có giá trị 1 đầu tiên trong dãy nhị phân xét từ phải sang trái. Để tìm được biểu diễn giá trị của bit này, ta sử dụng thao tác AND: x -x. Nếu giá trị trả về là 0 thì không có bit nào có giá trị 1.","Để tắt LSB, ta có 2 cách: x = x - (x -x) hoặc x = x (x - 1)"]},{"l":"Duyệt các tập con của bitmask","p":["Ta có một bitmask mask và giờ đây ta muốn duyệt các tập con của nó. Ta có cách thức vô cùng đơn giản:","Nếu muốn xét cả tập hợp rỗng, ta có thể chỉnh sửa lại:"]},{"l":"Các thao tác trong tập hợp","p":["\\bar{A}","\\neg A","A \\backslash B","A \\cap B","A \\cup B","A \\land (\\neg B)","A \\land B","A \\lor B","Giao","Hiệu","Hợp","Ký hiệu cho bit","Ký hiệu cho tập hợp","Như đã nói ở trên, bitmask có thể dùng để biểu diễn tập hợp. Bảng sau sẽ cho ta thấy các thao tác của tập hợp và cách áp dụng tương ứng với bitmask sử dụng các toán tử thao tác:","Phần bù","Thao tác"]},{"i":"một-số-hàm-liên-quan-đến-bit-trong-c","l":"Một số hàm liên quan đến bit trong C++","p":["Trình biên dịch g++ cung cấp cho ta một số hàm builtin cho các thao tác bit:","__builtin_clz(x): số lượng bit 0 ở đầu số x.","__builtin_ctz(x): số lượng bit 0 ở cuối số x.","__builtin_popcount(x): số lượng bit 1 có trong số x.","__builtin_parity(x): tính chẵn lẻ của số lượng bit 1 trong số x."]},{"i":"bitset-trong-c","l":"bitset trong C++","p":["1. Không gán trá trị: khi này các bit sẽ có giá trị là 0.","2. Gán trá trị bằng số: khi này các bit sẽ có giá trị tương ứng với các bit của số tương ứng khi biểu diễn thành số nhị phân.","3. Gán trá trị bằng xâu nhị phân: khi này các bit sẽ có giá trị tương ứng với các kí tự trong xâu nhị phân.","all()","any()","Câu lệnh","count()","Đảo giá trị bit ở tất cả các vị trí hoặc một vị trí pos","Đổi giá trị bit ở tất cả các vị trí hoặc một vị trí pos thành 0","Đổi giá trị bit ở tất cả các vị trí hoặc một vị trí pos thành 1","flip(pos)","int lưu được 32 bit, long long là 64. Nếu ta muốn lưu trữ nhiều bit hơn hoặc lưu số lương bit tùy ý thì ta sử dụng bitset trong thư viện bitset.","Khai báo:","Kích thước của bitset phải cố định.","Mô tả","Một số câu lệnh của bitset:","none()","reset(pos)","set(pos)","size()","Ta có thể gán các giá trị bit ban đầu cho bitset theo nhiều cách khác nhau:","Ta còn có thể thực hiện các thao tác bit trên bitset giống như với số nguyên. Ngoài ra để truy cập bit ta có thể sử dụng thao tác []. Ví dụ:","test(pos)","to_string()","to_ullong()","to_ulong()","Trả về biểu diễn unsigned long của bitset","Trả về biểu diễn unsigned long long của bitset","Trả về biểu diễn xâu kí tự của bitset","Trả về giá trị của bit ở vị trí pos","Trả về giá trị true nếu có ít nhất 1 bit được bật","Trả về giá trị true nếu không có bit nào được bật","Trả về giá trị true nếu tất cả các bit được bật","Trả về kích thước của bitset","Trả về số lượng bit được bật"]}],[{"l":"Thuật toán sắp xếp","p":["Thuật toán sắp xếp là thuật toán tối quan trọng trong lập trình thi đấu. Thuật toán sắp xếp là nền tảng để tối ưu các thuật toán khác, khi việc thực hiện các thao tác sẽ dễ dàng hơn khi các phần tử của một danh sách đã được sắp xếp."]},{"l":"Khái niệm","p":["Một bài toán sắp xếp kinh điển sẽ được phát biểu như sau:","Cho một mảng chứa n phần tử. Hãy sắp xếp và trả về các phần tử của mảng theo thứ tự tăng dần theo giá trị.","Ví dụ ta có mảng:","[2, 5, 7, 9, 1, 4, 6, 3, 8]","Thì sau khi sắp xếp ta có mảng mới","[1, 2, 3, 4, 5, 6, 7, 8, 9]"]},{"i":"các-thuật-toán-sắp-xếp-","l":"Các thuật toán sắp xếp O(n^{2})","p":["Các thuật toán sắp xếp O(n^{2}) thường khá đơn giản - thường khá ngắn và sử dụng 2 vòng lặp lồng nhau. Ta sẽ tìm hiểu một số thuật toán sắp xếp O(n^{2}) phổ biến."]},{"i":"sắp-xếp-nổi-bọt-bubble-sort","l":"Sắp xếp nổi bọt (Bubble sort)","p":["Thuật toán sắp xếp nổi bọt hoạt động như sau: Ta xét cặp 2 phần tử liên tiếp. Nếu phần tử đứng trước lớn hơn phần tử đứng sau, hoán đổi vị trí 2 phần tử. Lặp lại cho đến khi nào không còn cặp phần tử nào có thể hoán đổi vị trí.","Minh họa bằng video: Bubble-sort with Hungarian (\"Csángó\") folk dance"]},{"i":"sắp-xếp-chọn-selection-sort","l":"Sắp xếp chọn (Selection sort)","p":["thuật toán sắp xếp chọn hoạt động như sau: với mỗi vị trí i từ 1 đến n, ta sẽ tìm số nhỏ nhất từ vị trí i đến vị trí n và hoán đổi phần tử ở vị trí i với phần tử ở vị trí số nhỏ nhất ấy. Khi này, với mỗi lần hoàn tất duyệt phần tử thứ i, ta có i phần tử nhỏ nhất đã được sắp xếp tăng dần.","Minh họa bằng video: Select-sort with Gypsy folk dance"]},{"i":"sắp-xếp-chèn-insertion-sort","l":"Sắp xếp chèn (Insertion sort)","p":["Thuật toán sắp xếp chèn sẽ lần lượt sắp xếp 1 phần tử đầu tiên, sau đó là 2 phần tử, 3 phần tử, ..., cho tới khi toàn bộ n phần tử đã được sắp xếp. Với mỗi phần tử có chỉ số i từ 2 đến n, ta tìm chỉ số của phần tử lớn nhất không lớn hơn phần tử có chỉ số i, gọi là j. Sau đó, chèn phần tử có chỉ số i vào vị trí j trong mảng.","Minh họa bằng video: Insert-sort with Romanian folk dance"]},{"i":"các-thuật-toán-sắp-xếp--1","l":"Các thuật toán sắp xếp O(n \\log{n})","p":["Thuật toán sắp xếp có thể được tối ưu xuống còn O(n \\log{n}). Ta sẽ tìm hiểu một số thuật toán sắp xếp phổ biến."]},{"i":"sắp-xếp-trộn-merge-sort","l":"Sắp xếp trộn (Merge sort)","p":["Thuật toán sắp xếp trộn (Merge sort) là một thuật toán sắp xếp áp dụng mô hình chia để trị. Mô tả thuật toán:","Nếu kích cỡ mảng là 1, kết thúc sắp xếp.","Nếu kích cỡ lớn hơn 1:","Chia đôi mảng thành 2 mảng con có kích thước \\left\\lfloor \\frac{n}{2} \\right\\rfloor và \\left\\lceil \\frac{n}{2} \\right\\rceil","Sắp xếp 2 mảng con cách đệ quy bằng merge sort","Hợp 2 mảng con lại thành một mảng đã sắp xếp Độ phức tạp của thuật toán là O(n \\log{n}).","Minh hoạ bằng ảnh: Merge Sort","Minh họa bằng video: Merge-sort with Transylvanian-saxon (German) folk dance"]},{"i":"sắp-xếp-nhanh-quicksort","l":"Sắp xếp nhanh (QuickSort)","p":["Thuật toán sắp xếp nhanh là một thuật toán áp dụng mô hình chia để trị. Mặc dù độ phức tạp của thuật toán chậm nhất là O(n^{2}) thuật toán lại có độ phức tạp trung bình là O(n \\log{n}), và khi so sánh trên máy thì nhanh hơn sắp xếp trộn trong nhiều trường hợp. Mô tả thuật toán:","Nếu kích cỡ mảng là 1, kết thúc sắp xếp.","Nếu kích cỡ lớn hơn 1:","Chọn một phần tử bất kì trong mảng","Chia mảng ra thành 2 mảng con: Một mảng con chứa các số nhỏ hơn phần tử bất kì kia, một mảng con chứa các số còn lại","Sắp xếp 2 mảng con một cách đệ quy bằng quicksort","Hợp 2 con mảng con lại thành một mảng đã sắp xếp","Minh họa bằng video: Quick-sort with Hungarian (Küküllőmenti legényes) folk dance"]},{"i":"thuật-toán-sắp-xếp-nhỏ-hơn-","l":"Thuật toán sắp xếp nhỏ hơn O(n \\log {n})?","p":["Đến đây, ta tự hỏi rằng liệu có thuật toán sắp xếp nào có độ phức tạp còn nhỏ hơn O(n \\log {n}) không? Nếu như ta giới hạn ở việc so sánh giá trị giữa các phần tử thì điều này là không thể. Một mảng chứa n phần tử sẽ có tất cả n! cách sắp xếp. Với mỗi lần thực hiện một bước so sánh, số lượng cách sắp xếp giảm đi một nửa, suy ra số bước so sánh cần thực hiện để mảng được sắp xếp tăng dần sẽ là O(\\log{n!}). Sử dụng công thức Stirling, ta có: \\log{n!} = n \\log{n} - n + O(\\log{n}). Suy ra: O(\\log{n!}) = O(n\\log{n})."]},{"i":"sắp-xếp-đếm-counting-sort","l":"Sắp xếp đếm (Counting sort)","p":["Giới hạn O(n\\log{n}) ở trên sẽ chỉ áp dụng với các thuật toán so sánh các giá trị của phần tử. Nếu ta sử dụng phương pháp khác, độ phức tạp có thể thay đổi. Một trong những thuật toán sắp xếp ấy chính là sắp xếp đếm. Thuật toán sắp xếp đếm là một thuật toán sắp xếp nhanh các phần tử trong mảng, với các phần tử trong mảng là các số nguyên. Thuật toán sẽ đếm số lần xuất hiện của các giá trị có trong mảng, từ đấy sắp xếp lại các giá trị. Độ phức tạp của thuật toán sắp xếp này là O(n + k), với k là khoảng giá trị của các phần tử trong mảng. Dễ thấy, nếu k đủ nhỏ, độ phức tạp của sắp xếp nhanh sẽ hơn nhiều so với các thuật toán sắp xếp được nói ở trên."]},{"i":"thuật-toán-sắp-xếp-trong-c","l":"Thuật toán sắp xếp trong C++","p":["Việc tự tay viết cả một thuật toán sắp xếp rất tốn thời gian và rất dễ xảy ra sai sót. Vì vậy ta có thể dùng hàm sort có sẵn trong thư viện C++. Điều này không những giúp tiết kiệm thời gian viết mà còn giúp tối ưu chương trình khi những hàm trong thư viện C++ thường rất nhanh và hiệu quả. Hàm sort của C++ sẽ sắp xếp các số trong khoảng [l, r). Ví dụ: sắp xếp các phần tử trong mảng a từ vị trí 0 đến n - 1.","Hàm sort cũng có thể sắp xếp được string, với các kí tự được sắp xếp theo giá trị ASCII tương ứng:"]},{"i":"phép-so-sánh-trong-hàm-sort-c","l":"Phép so sánh trong hàm sort C++","p":["Hàm sort trong C++ yêu cầu một thao tác so sánh để có thể thực hiện việc so sánh các phần tử. Hầu hết các kiểu dữ liệu trong C++ đều có phép so sánh, ví dụ như int sắp xếp theo giá trị của nó. Kiểu dữ liệu pair sẽ được sắp xếp theo giá trị của giá trị đầu tiên trong cặp giá trị: first. Nếu có nhiều first bằng nhau thì sẽ sắp xếp theo giá trị còn lại của pair: second.","Sau khi sắp xếp xong mảng v sẽ có các phần tử được xắp xếp theo thứ tự lần lượt là (1, 2), (1, 5), (2, 3)."]},{"l":"Struct","p":["struct trong C++ mặc định không có thao tác so sánh. Vì vậy ta phải tự viết thao tác với mỗi struct mà ta muốn thực hiện việc sắp xếp bằng hàm sort. Ví dụ:","struct phanso ở ví dự trên có thao tác so sánh theo giá trị của \\frac{a}{b}:"]},{"l":"Hàm so sánh","p":["Ta có thể viết hàm so sánh để sắp xếp các phần tử: Ví dụ:","Mảng a sau khi sắp xếp xong sẽ cho ta các phần tử theo thứ tự: (1, 2), (2, 3), (4, 2)."]}],[{"l":"Thuật toán tìm kiếm nhị phân","p":["Bài toán mở đầu: Cho một mảng a chứa n phần tử phân biệt được sắp xếp tăng dần. Kiểm tra xem có tồn tại phần tử có giá trị x trong mảng hay không.","Để giải quyết bài toán này, ta có thể duyệt qua tất cả các phần tử và kiểm tra phần tử nào có giá trị bằng x, nhưng độ phức tạp thời gian sẽ là O(n). Ta có thể giải được bài toán này một cách tối ưu bằng các sử dụng thuật toán tìm kiếm nhị phân."]},{"l":"Thuật toán","p":["Ta nhận xét, vì mảng a đã được sắp xếp tăng dần, nên phần tử đứng sau luôn lớn hơn phần tử đứng trước. Giả sử phần tử a[i] nhỏ hơn x, ta có thể nhận thấy ngay được rằng mọi phần tử đứng sau a[i] đều nhỏ hơn x. Khi này, ta có thuật toán nhị phân:","Tìm giá trị của phần tử ở giữa mảng.","Xét trường hợp:","Nếu phần tử bằng x, vậy ta kết luận có phần tử có giá trị bằng x. Khi này ta kết thúc tìm kiếm nhị phân.","Nếu phần tử nhỏ hơn x, phần tử ấy và mọi phần tử đứng sau nó đều nhỏ hơn x. Loại bỏ tất cả phần tử từ đầu mảng đến phần ở giữa ấy.","Nếu phần tử ấy lớn hơn x, phần tử ấy và mọi phần tử đứng trước nó đều lớn hơn x. Loại bỏ tất cả phần tử từ cuối mảng đến phần tử ấy.","Tiếp tục thực hiện tìm kiếm nhị phân cho tới khi không còn phần tử nào để thực hiện việc tìm kiếm, khi này ta thông báo rằng mảng không tồn tại phần tử có giá trị x.","Vì mỗi lần ta tìm kiếm ta giảm đi một nửa số phần tử trong mảng, nên độ phức tạp thời gian của thuật toán tìm kiếm nhị phân sẽ là O(\\log{n})."]},{"l":"Tìm kiếm nhị phân trên hàm đơn điệu","p":["Ta có một hàm f(x) trả về một trong hai giá trị true hoặc false. Trong nhiều bài toán, ta được yêu cầu tìm giá trị x lớn nhất hoặc nhỏ nhất sao cho f(x) = true. Giống với bài toán tìm phần tử trên mảng, ta cũng có thể giải quyết dạng bài này bằng tìm kiếm nhị phân nếu hàm f(x) là một hàm đơn điệu, tức giá trị của hàm không giảm hoặc không tăng."]},{"l":"Tìm kiếm giá trị nhỏ nhất","p":["Bài toán yêu cầu tìm một giá trị k mà f(x) = false với x \\lt k và f(x) = true với x \\ge k. Ta có bảng sau:","x","0","1","...","k - 1","k","k + 1","f(x)","false","true","Từ đây, ta có thể tìm k bằng tìm kiếm nhị phân:"]},{"l":"Tìm kiếm giá trị lớn nhất","p":["Bài toán yêu cầu ta tìm một giá trị k mà f(x) = false với x \\gt k và f(x) = true với x \\le k. Ta cũng tìm k bằng tìm kiếm nhị phân giống như cách ở trên:"]},{"l":"Tìm kiếm nhị phân đáp án","p":["Ta có dạng bài toán được phát biểu như sau: Tất cả các số được chia làm số đẹp và không đẹp. Nếu x là một số đẹp thì x + 1 cũng là số đẹp. Tìm số đẹp nhỏ nhất. Dễ thấy, dạng bài toán này giống với tìm kiếm nhị phân trên hàm đơn điệu được nói ở phần trên. Chính vì thế bài toán này có thể được giải quyết bằng tìm kiếm nhị phân. Ta sẽ ứng dụng cách giải quyết này cho bài toán sau: Cho n hình chữ nhật kích thước a \\times b. Tính độ dài của hình vuông nhỏ nhất chứa tất cả n hình chữ nhật này. Ta tạo hàm f(x) trả về true nếu hình vuông cạnh x chứa được tất cả n hình chữ nhật, và false nếu không thể. Ta biết được f(x) là một hàm đơn điệu vì nếu ta có thể xếp n hình chữ nhật vào hình vuông cạnh x thì ta cũng thực hiện được với hình vuông cạnh x + 1. Ta có số lượng hình chữ nhật a \\times b nhiều nhất có thể được xếp trong hình vuông cạnh x là \\left\\lfloor \\frac{x}{a} \\right\\rfloor \\times \\left\\lfloor \\frac{x}{b} \\right\\rfloor(người đọc tự chứng minh). Từ đây ta có hàm f(x):","f(x) = 1 nếu \\left\\lfloor \\frac{x}{a} \\right\\rfloor \\times \\left\\lfloor \\frac{x}{b} \\right\\rfloor \\le n","f(x) = 0 trong trường hợp ngược lại.","Việc còn lại bây giờ là tìm kiếm nhị phân số x nhỏ nhất mà f(x) = 1."]},{"l":"Tìm kiếm nhị phân với số thực","p":["Với cách thực hiện tìm kiếm nhị phân với số thực thì ta cần có cách áp dụng thuật toán theo cách khác. Số thực khó so sánh bằng, như đã nói ở phần số thực, nếu sử dụng kiểu while (l = r), vòng lặp sẽ chạy vô tận và chương trình sẽ bị TLE. Để thực hiện việc tìm kiếm nhị phân với số thực, ta chỉnh sửa code như sau:","Thay đổi [iterator_count] để tạo sự cân bằng giữa độ chính xác kết quả và tốc độ thuật toán. Thường thì ta sẽ chọn 100 cho [iterator_count]."]},{"i":"hàm-tìm-kiếm-nhị-phân-trong-c","l":"Hàm tìm kiếm nhị phân trong C++","p":["C++ có các hàm dựa trên tìm kiếm nhị phân:","Hàm lower_bound trả về vị trí phần tử đầu tiên có giá trị lớn hơn hoặc bằng x","Hàm upper_bound trả về vị trí phần tử đầu tiên có giá trị lớn hơn x","Hàm equal_range trả về 2 vị trí lower_bound và upper_bound","Code dưới đây đếm số phần tử có giá trị bằng x.","Có thể được rút gọn bằng equal_range:","Bonus: BINARY search with FLAMENCO dance"]}],[{"l":"Kĩ thuật hai con trỏ","p":["Kĩ thuật hai con trỏ là kĩ thuật sử dụng hai con trỏ để thực hiện việc duyệt các phần tử trong mảng.","Nghe thì đơn giản nhưng đây lại là một kĩ thuật rất hữu ích với nhiều ứng dụng khác nhau. Hãy cùng tim hiểu một số ứng dụng của kĩ thuật hai con trỏ qua một số bài toán."]},{"l":"Gộp mảng","p":["Cho 2 mảng a và b được sắp xếp tăng dần. In ra một mảng c gồm các phần tử của 2 mảng kia được sắp xếp theo thứ tự tăng dần.","Cách dễ nhất để thực hiện bài toán này là một thuật toán gồm các bước như sau:","Gộp tất cả các phần tử trong 2 mảng vào một mảng mới","Sắp xếp mảng mới này","Thuật toán này đơn giản và có độ phức tạp là O(n \\log{n}). Tuy nhiên, xét đến việc các phần tử trong 2 mảng đã được sắp xếp tăng dần, ta có thể sử dụng kĩ thuật 2 con trỏ để tạo mảng c với độ phức tạp nhỏ hơn. Chương trình của ta có các bước như sau:","Khi hai phần tử đều không rỗng, tìm phần tử nhỏ nhất của 2 mảng a và b. Nếu phần tử nhỏ nhất của a nhỏ hơn của b thì thêm phần tử đấy vào mảng c là loại bỏ phần tử ấy khỏi a, nếu không thì ngược lại.","Tiếp tục thực hiện bước trên cho tới khi một trong hai mảng rỗng. Khi đấy ta thêm các phần tử còn lại của mảng còn lại vào mảng c.","Ta có ví dụ sau: a = [1, 3, 4], b = [2, 5, 6]","Vì mảng a đã được sắp xếp tăng dần nên phần tử đầu tiên của mảng a là phần tử nhỏ nhất, mảng b cũng tương tự. 1 và 2 là phần tử nhỏ nhất của 2 mảng. Vì 1 là phần tử nhỏ hơn nên ta thêm 1 vào mảng c và loại bỏ 1 khỏi mảng a.","a = [\\color{red}{\\not{1}}, 3, 4], b = [2, 5, 6], c = [1]","Vì 1 đã được xóa bỏ nên ta xét phần tử nhỏ nhất tiếp theo của mảng a là 3. Vì 2 là phần tử nhỏ hơn nên ta tiếp tục thuật toán:","a = [\\color{red}{\\not{1}}, 3, 4], b = [\\color{red}{\\not{2}}, 5, 6], c = [1, 2]","Và ta tiếp tục thuật toán cho tới khi cả 2 mảng đều rỗng. Để thực hiện thuật toán này, ta sử dụng kĩ thuật hai con trỏ. Ta tạo 2 con trỏ i và j cho 2 mảng a và b. 2 con trỏ này sẽ trỏ vào vị trí phần tử đầu tiên của 2 mảng. Mỗi lần một con trỏ trỏ đến phần tử được chọn, con trỏ đấy sẽ di chuyển đến vị trí tiếp theo trong mảng. a = [\\color{red}{\\not{1}}, \\overset{\\underset{\\downarrow}{i}}{3}, 4], b = [\\underset{\\overset{\\uparrow}{j}}{2}, 5, 6] Ta có n, m lần lượt là kích thước của mảng a và b, phần tử đầu tiên của 2 mảng có chỉ số 1. Mảng nào có con trỏ trỏ ra ngoài mảng thì ta sẽ thêm các phần tử còn lại của mảng kia vào mảng c.","Độ phức tạp thuật toán sẽ là O(n + m)."]},{"l":"Bài toán 2SUM","p":["Bài toán 2SUM được phát biểu như sau: Cho một mảng n phần tử và một số x. Tìm cặp số có tổng giá trị bằng x hoặc thông báo rằng cặp số ấy không tồn tại.","Để giải bài toán này, ta sẽ sắp xếp các phần tử trong mảng và đặt 2 con trỏ ở hai vị trí đầu và cuối mảng. Nếu tổng của các phần tử được 2 con trỏ trỏ tới có tổng lớn hơn x, ta dịch con trỏ ở cuối mảng sang trái, nếu nhỏ hơn thì dịch con trỏ ở đầu mảng sang phải. Tiếp tục thực hiện cho tới khi tìm được cặp số thỏa mãn, hoặc khi không thể duyệt được nữa.","Ta ví dụ bằng mảng sau và một số x = 11:","[1, 2, 3, 5, 8, 9, 12, 15]","Ta để hai con trỏ ở vị trí ban đầu.","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, 2, 3, 5, 8, 9, 12, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{15}}]","Dễ thấy, 1 + 15 = 16 \\gt 11. Vì vậy, ta dịch con trỏ j sang trái.","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, 2, 3, 5, 8, 9, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{12}}, 15]","1 + 12 = 13 \\gt 11, tiếp tục dịch con trỏ j sang trái.","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, 2, 3, 5, 8, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{9}}, 12, 15]","1 + 9 = 10 \\lt 11, khi này dịch con trỏ i sang phải.","[1, \\overset{\\underset{\\downarrow}{i}}{\\color{red}{2}}, 3, 5, 8, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{9}}, 12, 15]","Khi này, $2 + 9 = 11 $, mảng tồn tại cặp số có tổng bằng x.","Độ phức tạp của thuật toán là O(n \\log{n})"]},{"l":"Tổng mảng con","p":["[\\overset{\\underset{\\downarrow}{i, j}}{\\color{red}{1}}, 4, 2, 6, 3, 7, 5]","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, \\color{red}{4}, \\color{red}{2}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{6}}, 3, 7, 5]","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, \\color{red}{4}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{2}}, 6, 3, 7, 5]","[\\overset{\\underset{\\downarrow}{i}}{\\color{red}{1}}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{4}}, 2, 6, 3, 7, 5]","[1, \\overset{\\underset{\\downarrow}{i}}{\\color{red}{4}}, \\color{red}{2}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{6}}, 3, 7, 5]","[1, 4, \\overset{\\underset{\\downarrow}{i}}{\\color{red}{2}}, \\color{red}{6}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{3}}, 7, 5]","[1, 4, \\overset{\\underset{\\downarrow}{i}}{\\color{red}{2}}, \\overset{\\underset{\\downarrow}{j}}{\\color{red}{6}}, 3, 7, 5]","[1, 4, 2, 6, 3, 7, 5]","Bài toán được phát biểu như sau: Cho một mảng n phần tử nguyên dương và một số x. Tìm mảng con có tổng giá trị bằng x hoặc thông báo rằng mảng con ấy không tồn tại.","Cách giải bài toán này gần giống với bài toán 2SUM ở trên:","Đặt i, j ở vị trí 1.","Dịch i sang phải.","Dịch j sang phải.","Hai con trỏ i và j của ta sẽ được đặt tại vị trí đầu mảng.","Nếu SUM(i, j) < x, dịch j sang phải. Nếu SUM(i, j) > x, dịch i sang phải. Nếu SUM(i, j) = x, đã tìm được mảng con có tổng bằng x.","Nhận xét","Sau thao tác","SUM(1, 1) = 1 < 11","SUM(1, 2) = 5 < 11","SUM(1, 3) = 7 < 11","SUM(1, 4) = 13 > 11","SUM(2, 4) = 12 > 11","SUM(3, 4) = 8 < 11","SUM(3, 5) = 11","Ta có SUM(l, r) là tổng giá trị các phần tử a_l, a_{l + 1},..., a_{r - 1}, a_{r}.","Ta ví dụ bằng mảng sau và một số x = 11:","Thao tác","Tồn tại mảng con có tổng bằng x, kết thúc thuật toán."]}],[{"i":"ngăn-xếp-stack","l":"Ngăn xếp (Stack)"},{"l":"Định nghĩa","p":["Stack (ngăn xếp) là một CTDL lưu trữ các phần tử gồm 2 thao tác chính:","Push: Thêm một phần tử vào cuối danh sách, và","Pop: Loại bỏ phần tử ở cuối danh sách.","Ngoài ra, giá trị phần tử ở đỉnh stack có thể được biết bằng thao tác Peek.","Ta có thể hình dung stack như một chồng đĩa: Chiếc đĩa cuối cùng được cho vào và đĩa nằm trên các đĩa còn lại và sẽ là đĩa đầu tiên được lấy ra. Quá trình này được mô tả là Last In, First Out - LIFO (Vào sau, ra trước)."]},{"l":"Cài đặt","p":["Ta cài đặt stack bằng mảng:","Cho một mảng st và chỉ số top.","Để thêm một phần tử, gán st[top] với một giá trị và tăng chỉ số top lên 1.","Để loại bỏ một phần tử, giảm chỉ số của top xuống 1.","Giá trị ở cuối mảng sẽ là giá trị ở đỉnh stack: st[top]","Stack rỗng khi trong mảng không có phần tử: top = 0","Kích thước của stack là số phần tử là số phần tử trong stack: top","Dễ thấy, các thao tác của stack đều có độ phức tạp thời gian là O(1)."]},{"l":"Stack trong thư viện chuẩn","p":["Để sử dụng stack trong thư viện chuẩn, ta khai báo thư viện stack trong C++.","Khai báo stack:","Các phương thức phổ biến của stack:","push(x): Thêm phần tử x vào stack","pop(): Loại bỏ một phần tử ở đầu stack","top(): Trả về giá trị của phần tử ở đỉnh stack","empty(): Trả về giá trị đúng nếu stack không có phần tử và ngược lại","size(): Trả về số phần tử trong stack","Giống như khi ta cài đặt thủ công, các thao tác nói trên có độ phức tạp thời gian O(1).","Ta cũng có thể cài stack bằng cách sử dụng vector.","Ta có:","push_back(x)= push(x)","pop_back()= pop()","back()= top()"]},{"l":"Ứng dụng","p":["Dưới đây là một số ứng dụng của stack."]},{"l":"Xử lí các sự kiện theo trình tự LIFO","p":["Bài ví dụ: Backspace - OpenKattis.","Lời giải: Ta dùng string để biểu diễn stack. Với mỗi kí tự được xét từ trái sang phải, nếu gặp dấu thì xóa kí tự cuối trong xâu, nếu không thì thêm kí tự vào cuối xâu.","Bài giải:"]},{"l":"Ký pháp nghịch đảo Ba Lan","p":["Ký pháp nghịch đảo Ba Lan (Reverse Polish notation - RPN) hay kí pháp hậu tố (postfix notation), là một phương pháp viết các biểu thức toán học, với các toán tử (ta sẽ giới hạn với các toán tử cộng, trừ, nhân, chia) được viết sau các toán hạng. Từ Ba lan trong tên gọi dùng để chỉ quốc tịch của người phát minh ra kí pháp là Jan Łukasiewicz.","Giả sử ta có biểu thức được viết ở dạng kí pháp trung tố (infix notation)- toán tử được viết ở giữa các toán hạng:","4 \\times (1 + 2 \\times (9 / 3) - 5)","thì khi viết theo RPN sẽ được biểu diễn thành:","4\\ 1\\ 2\\ 9\\ 3\\ / \\times +\\ 5 - \\times","Cái lợi của RPN chính là ta có thể tính toán một biểu thức mội cách dễ dàng trong thời gian tuyến tính.","Ta sử dụng một stack. Khi duyệt biểu thức từ trái sang phải, nếu phần tử được xét đến là một toán hạng, ta thêm phần tử ấy vào stack. Nếu là một toán tử thì ta sẽ thực hiện việc tính 2 toán hạng ở đỉnh stack với toán tử tương ứng. Sau đó, thêm kết quả tương ứng vào stack của ta. Sau khi duyệt xong, phần tử ở đỉnh stack (đồng thời cũng là phần tử duy nhất còn trong stack) sẽ là giá trị của biểu thức."]},{"l":"Chuyển từ trung tố sang hậu tố","p":["-","(",")","/","\\times","\\times(","\\times( -","\\times( +","\\times( + \\times","\\times( + \\times(","\\times( + \\times( /","+","1","2","3","4","4 1","4 1 2","4 1 2 9","4 1 2 9 3","4 1 2 9 3 /","4 1 2 9 3 / \\times+","4 1 2 9 3 / \\times+ 5","4 1 2 9 3 / \\times+ 5 -","4 1 2 9 3 / \\times+ 5 - \\times","5","9","Để chuyển một biểu thức từ hạng trung tố sang hậu tố, ta sử dụng thuật toán shunting yard của Dijkstra.","Dữ liệu ra","Ghi chú","In các toán tử còn lại","In ra 5","In số 1","In số 2","In số 3","In số 4","In số 9","In, loại bỏ các toán tử","Kết thúc","Loại bỏ các toán tử có thứ tự ưu tiên lớn hơn hoặc bằng","Loại bỏ cho tới khi gặp \"(\", đồng thời xóa luôn \"(\"","Nếu là dấu đóng ngoặc, loại bỏ và in ra các phần tử có trong stack cho tới khi phần tử ở đỉnh là dấu mở ngoặc, và loại bỏ dấu mở ngoặc này khỏi stack.","Nếu là dấu mở ngoặc, ta thêm dấu ấy vào stack.","Nếu là toán tử thì trước khi thêm toán hạng ấy vào stack, ta sẽ thực hiện việc in và loại bỏ các toán tử có thứ tự ưu tiên lớn hơn hoặc bằng toán tử đang xét (thứ tự ưu tiên của các toán tử cộng trừ nhân chia giống với quy tắc thực hiện tính biểu thức: nhân chia trước, cộng trừ sau, thực hiện các phép tính từ trái sang phải) cho tới khi ta không còn có thể loại bỏ toán tử khỏi stack hoặc phần tử ở đỉnh stack là dấu mở ngoặc.","Nếu phần tử đang xét là một toán hạng, ta in thẳng các toán hạng.","Phần tử","Qua đoạn code trên, ta thấy thuật toán hoạt động vô cùng đơn giản trong thời gian tuyến tính.","Sau khi kết thúc duyệt, nếu stack không rỗng thì in nốt các toán hạng còn lại trong stack cho tới khi stack rỗng.","Sau khi kết thúc thuật toán shunting yard, ta thành công chuyển đổi biểu thức từ dạng kí pháp trung tố thành kí pháp hậu tố.","Stack","Ta có code được viết như sau:","Ta cũng ví dụ bằng biểu thức ở đầu:","Thao tác","Thêm vào stack","Thứ hạng ưu tiên của \\times lớn hơn +"]},{"l":"Dãy ngoặc đúng","p":["Ta ví dụ một bài toán:","Cho xâu S gồm các kí tự ( và ). Kiểm tra xem xâu S có phải là một dãy ngoặc đúng không? Định nghĩa:","Xâu rỗng là một dãy ngoặc đúng.","Nếu A là dãy ngoặc đúng thì (A) cũng là một dãy ngoặc đúng.","Nếu A và B là dãy ngoặc đúng thì AB cũng là một dãy ngoặc đúng.","Ý tưởng: Duyệt qua từng dấu ngoặc trong dãy ngoặc. Nếu gặp dấu ngoặc mở thì thêm vào stack, nếu là dấu ngoặc đóng thì loại bỏ một dấu ngoặc mở trong stack. Dãy ngoặc sẽ không được gọi là dãy ngoặc đúng nếu trong lúc duyệt đến dấu ngoặc đóng thì stack rỗng hoặc sau khi duyệt xong thì stack không rỗng."]},{"l":"Khử đệ quy bằng stack","p":["Stack có thể được dùng để thực hiện các thuật toán đệ quy nhờ vào tính chất LIFO. Thực tế, khi chạy chương trình sẽ có một stack riêng biệt chịu trách nhiệm trong việc quản lí các hàm. Stack ấy được gọi là call stack. Khi một hàm được gọi call stack sẽ lưu các lần gọi hàm và các dữ liệu liên quan và chỉ bị xóa đi khi hàm đã thực hiện xong.","Ta ví dụ với hàm tính giai thừa:","Trước tiên main() sẽ được thêm vào call stack, tiếp theo là f(5), f(4) cho tới f(1). Khi này ta có hình minh họa:","Sau khi hàm f(1) thực hiện xong, nó sẽ trả về giá trị và được xóa khỏi call stack. Tiếp đến là f(2), f(3) tới f(5) và chương trình của ta đã chạy xong!","Nếu ta gọi các hàm quá nhiều, call stack sẽ tràn bộ nhớ và ta nhận về lỗi Stack Overflow.","Để giải quyết việc này, ta thực hiện việc khử đệ quy. Thay vì để máy tính tự tạo một call stack, ta sẽ tự tạo call stack trong bộ nhớ chương trình của ta.","Ta có cài đặt thuật toán DFS sử dụng stack:","Ta áp dụng việc khử đệ quy khi hàm đệ quy quá sâu và có thể xảy ra lỗi Stack Overflow."]},{"l":"Stack đơn điệu","p":["Stack đơn điệu là kiểu stack mà các phần tử từ đáy đến đỉnh có giá trị tăng dần hoặc giảm dần.","Ta ví dụ một bài toán:","Cho mảng a có n phần tử bắt đầu từ chỉ số 1. Với mỗi phần tử trong mảng, tìm phần tử gần nhất bên trái có giá trị lớn hơn phần tử đang xét. Nếu phần tử ấy không tồn tại thì in ra -1.","Với cách giải thông thường, ta sẽ sử dụng 2 vòng lặp lồng nhau để giải bài toán.","Độ phức tạp thuật toán là O(n^2).","Để tối ưu thuật toán, ta thực hiện các bước sau với mọi i từ 1 đến n:","Trước khi thêm vào a_i, thực hiện loại bỏ các phần tử ở đỉnh stack cho đến khi đỉnh stack có giá trị lớn hơn a_i hoặc stack rỗng.","Nếu stack rỗng, ta in giá trị thông báo không có phần tử thỏa mãn, nếu không rỗng thì in ra phần tử ở đỉnh stack.","Thêm a_i vào stack.","Dễ thấy các giá trị trong stack sẽ tạo thành dãy đơn điệu tăng dần từ đáy đến đỉnh stack.","Độ phức tạp thuật toán là O(n).","Mặc dù thuật toán của ta có 2 vòng lặp lồng nhau, nhưng nếu để ý kĩ thì mỗi phần tử trong mảng sẽ được push một lần và pop nhiều nhất 1 lần. Vậy nên độ phức tạp sẽ là O(n)."]}],[{"i":"hàng-đợi-queue","l":"Hàng đợi (Queue)"},{"l":"Định nghĩa","p":["Queue (hàng đợi) là một CTDL lưu trữ các phần tử gồm 2 thao tác chính:","Push: Thêm một phần tử vào cuối danh sách, và","Pop: Loại bỏ phần tử ở đầu danh sách","Ta hiểu về queue giống như một queue (hàng đợi) ở ngoài đời vậy: Người đầu tiên xếp vào hàng sẽ là người đầu tiên ra khỏi hàng đợi, người thứ hai vào hàng sẽ là người thứ hai ra khỏi đó, v.v. Vì tích chất này, queue còn được gọi là danh sách First In, First out - FIFO (Vào trước, ra trước)."]},{"l":"Queue trong thư viện chuẩn","p":["Ta có thể sử dụng queue trong C++ bằng cách khai báo thư viện queue.","Khai báo queue:","Các phương thức phổ biến của queue:","push(x): Thêm phần tử x vào queue","pop(): Loại bỏ một phần tử ở đầu queue","front(): Trả về giá trị của phần tử ở đầu queue","back(): Trả về giá trị của phần tử ở cuối queue","empty(): Trả về giá trị đúng nếu queue không có phần tử và ngược lại","size(): Trả về số phần tử trong queue","Các thao tác đều có độ phức tạp O(1)."]},{"l":"Ứng dụng","p":["Một trong những thuật toán sử dụng hàng đợi là thuật toán BFS."]}],[{"i":"hàng-đợi-hai-đầu-deque","l":"Hàng đợi hai đầu (Deque)"},{"l":"Định nghĩa","p":["Hàng đợi hai đầu (Double-ended queue - deque, dequeue) là một CTDL cho phép việc thêm và loại bỏ phần tử ở đầu và cuối phần tử.","Deque cũng giống như một hàng đợi bình thường nhưng khác ở chỗ các phần tử ở cuối queue có thể được loại bỏ. Giống như khi bạn đi siêu thị và đứng xếp hàng tại quầy. Nếu có quá nhiều người xếp hàng chờ thanh toán thì bạn có thể rời từ cuối hàng và sang quầy khác."]},{"l":"Deque trong thư viện chuẩn","p":["at(x), thao tác []: Trả về giá trị của phần tử trong deque tại một chỉ số","back(): Trả về giá trị của phần tử ở cuối queue","Các phương thức phổ biến của deque:","Các phương thức trên đều có độ phức tạp O(1), ngoại trừ clear() có độ phức tạp O(n).","Các thao tác chính:","Các thao tác khác:","clear(): Xóa toàn bộ các phần tử trong deque","empty(): Trả về giá trị đúng nếu deque không có phần tử và ngược lại","front(): Trả về giá trị của phần tử ở đầu queue","Khai báo deque:","pop_back(): Loại bỏ phần tử ở cuối deque","pop_front(): Loại bỏ phần tử ở đầu deque","push_back(x): Thêm phần tử x vào cuối deque","push_front(x): Thêm phần tử x vào đầu deque","size(): Trả về số phần tử trong deque","Ta khai báo thư viện deque trong C++ để sử dụng deque."]},{"l":"Ứng dụng"},{"i":"thay-thế-stack-queue","l":"Thay thế stack, queue","p":["Với nhiều thao tác như thế, deque hoàn toàn có thể thực hiện các thao tác của stack và queue.","Thực tế, nếu bạn đọc thông tin về stack và queue trên cppreference.com thì ẩn trong 2 CDTL chính là deque."]},{"i":"bfs-0---1","l":"BFS 0 - 1","p":["Deque được dùng để giải quyết bài toàn tìm đường đi ngắn nhất bằng BFS: BFS 0 - 1."]},{"l":"Deque trên đoạn tịnh tiến","p":["Ta có bài toán: Cho mảng a có n phần tử bắt đầu từ chỉ số 1. Với mỗi đoạn con có độ dài k, tìm phần tử nhỏ nhất với mỗi đoạn con này.","Ví dụ với n = 9 và k = 3 và mảng a: [1, 5, 6, 2, 8, 3, 4, 9]","Ta có giá trị nhỏ nhất của các đoạn [1, 3], [2, 4], ..., [7, 9] lần lượt là:","[1, 3]: 1","[2, 4]: 2","[3, 5]: 2","[4, 6]: 2","[5, 7]: 2","[6, 8]: 3","[7, 9]: 3","Có một cách giải quyết tối ưu bài toán này, áp dụng tư tưởng của stack đơn điệu.","Với mỗi i, ta thêm phần tử có chỉ số i vào cuối deque. Trước khi thêm vào, loại bỏ các phần tử ở cuối deque có giá trị lớn hơn phần tử sẽ được thêm vào. Khi này phần tử ở đầu deque là phần tử nhỏ nhất trong khoảng tử đầu mảng đến phần tử chỉ số i.","Để giải quyết bài toán gốc, ta thực hiện việc xóa phần tử như sau: Xóa các phần tử ở đầu deque nếu chỉ số của phần tử ấy nhỏ hơn i - k + 1. Sau khi xóa xong, phần tử ở đầu deque sẽ là phần tử ở đầu hàng đợi hai đầu này.","Độ phức tạp của thuật toán là O(n)."]}],[{"i":"bảng-thưa-sparse-table","l":"Bảng thưa (Sparse Table)","p":["Ta có bài toán sau: Cho một mảng a có n phần tử và q truy vấn có dạng (l, r). Với mỗi truy vấn, tìm và in ra giá trị nhỏ nhất (GTNN) của các phần tử trong khoảng [l, r].","Bài toán này có tên là Range Minimum Query (RMQ)(dịch tạm: Truy vấn tìm GTNN trên đoạn). Ta có thể giải bài toán này bằng cách duyệt các phần tử từ l tới r và in ra GTNN trong khoảng đó. Độ phức tạp của thuật toán này là O(nq). Tuy nhiên, ta có thể sử dụng một kĩ thuật giúp giải quyết bài toán này và các bài toán trên đoạn khác một cách tối ưu. Kĩ thuật này có tên gọi là kĩ thuật bảng thưa."]},{"l":"Ý tưởng","p":["Trước khi bàn về bảng thưa, ta cùng xét trường hợp nếu n nhỏ và q lớn, ví dụ: n \\le 1000, q \\le 10^5.","Ta có f(i, j) là một hàm trả về GTNN trong đoạn [i, j], ta lưu tất cả các giá trị của f(i, j) vào một mảng hai chiều F, với F[i][j] = f(i, j). Giờ đây, các truy vấn có thể được thực hiện trong O(1) bằng cách in ra F[l][r].","Thuật toán của ta giờ đây cần O(n^2) để tính các giá trị f(i, j), và mỗi truy vấn có thể trả lời trong O(1).","Gọi bảng F này là bảng dày. Để bảng dày này trở thành bảng thưa, ta cần phải tự hỏi xem: liệu có lần phải lưu hết tất cả các giá trị trong bảng dày này hay không?"]},{"l":"Bảng thưa"},{"l":"Trực quan","p":["Giống như một số nguyên có thể được biểu diễn bằng tổng của các lũy thừa của 2:","21 = 10101_2 = 2^4 + 2^2 + 2^0","Các đoạn [l, r] có thể được biểu diễn bằng hợp của các đoạn có độ dài là lũy thừa của 2:","[7, 21] = [7, 7 + 2^3) \\cup [15, 15 + 2^2) \\cup [19, 19 + 2^1) \\cup [21, 21 + 2^0)","Tương đương:","[7, 21] = [7, 15) \\cup [15, 19) \\cup [19, 21) \\cup [21, 22)","Với các đoạn [7, 15), [15, 19), [19, 21), [21, 22) có kích thước lần lượt là 8, 4, 2, 1.","Từ đây, ta có ý tưởng xây dựng bảng thưa: Thay vì lưu trữ toàn bộ các GTNN của các đoạn, ta chỉ cần lưu giá trị của các đoạn có độ dài bằng các lũy thừa của 2."]},{"l":"Xây dựng bảng thưa","p":["...","0","1","10","11","12","2","3","4","5","6","7","8","9","Để xây dựng bảng thưa, ta có mảng 2 chiều sp. sp[k][i] sẽ bằng GTNN của các phần tử trong khoảng [i, i + 2^k).","k\\ i","Nhận xét: số phần tử của sp sẽ không quá O(n\\log{n}). Nếu các phần tử được tính trong O(1) thì việc tạo mảng sp sẽ có độ phức tạp O(n\\log{n}).","sp[0][3] = min(a[3]) = a[3].","sp[0][i] = a[i]","sp[1][3] = min(a[3], a[4]).","sp[2][3] = min(a[3], a[4], a[5], a[6]).","sp[k][3] = min(a[3], a[4], ..., a[3 + 2^k - 2], a[3 + 2^k - 1]).","sp[k][i] = min(sp[k - 1][i], sp[k - 1][i + 2 ^ {k - 1}])","Ta có công thức tính sp[i][k] như sau:","Ta ví dụ với mảng a có 12 phần tử: a = [1, 4, 2, 3, 7, 2, 6, 3, 5, 8, 9, 0]","Ví dụ:","Vì sao lại có một số phần tử lại không được tính? Ví dụ với phần tử (10, 2) lưu GTNN trong khoảng [10, 13], nhưng khoảng này lại tràn ra ngoài bảng thưa (mảng nằm trong khoảng [1, 12] nhưng lại tính GTNN của khoảng [10, 13]) nên ta không cần (nói đúng hơn là không thể) tính được, vì thế ta bỏ qua việc tính GTNN tại vị trí này trong bảng.","X"]},{"l":"Xử lý truy vấn","p":["Đối với các hàm có tính chất kết hợp, hay các hàm có tính chất f(f(x, y), z) = f(x, f(y, z)), các truy vấn có thể được xử lý trong O(\\log{n}).","Ta sẽ chia đoạn [l, r] thành các phân đoạn có độ dài bằng các lũy thừa của 2 và tìm GTNN của các phân đoạn:","Ví dụ: Truy vấn [8, 17] có GTNN bằng min(sp[3][8], sp[1][16]).","Ta có thể tìm nhanh vị trí của giá trị bit lớn nhất của một số x trong C++ bằng cách sử dụng hàm __lg(x).","Đối với các hàm cho phép trùng lặp các phần tử, hay các hàm thỏa mãn f(a, a) = a, ta có thể thực hiện việc tính kết quả trong O(1).","Ta thực hiện việc tìm GTNN như sau:","Gọi k là số nguyên lớn nhất sao cho 2^k \\le r - l + 1, GTNN của đoạn (l, r) bằng:","min(l, r) = min(sp[k][l], sp[k][r - 2 ^ {k} + 1])"]},{"l":"Ứng dụng","p":["Bảng thưa thường được dùng để tìm các giá trị trong một khoảng một cách nhanh chóng. Các giá trị như tổng, tích, giá trị nhỏ/lớn nhất, gcd, lcm,... Những giá trị còn được dùng để giải quyết các bài toán lớn hơn, ví dụ như: tìm LCA trong O(1), nâng nhị phân,...","Bảng thưa chỉ có thể được sử dụng trên mảng tĩnh, tức các giá trị trên mảng không thay đổi."]}],[{"i":"cây-phân-đoạn-segment-tree","l":"Cây phân đoạn (Segment Tree)","p":["Quay lại với bài toán ở phần bảng thưa:","Cho một mảng a có n phần tử và q truy vấn có dạng (l, r). Với mỗi truy vấn, tìm và in ra giá trị nhỏ nhất (GTNN) của các phần tử trong khoảng [l, r].","Mảng a ví dụ:","a = [5, 2, 7, 8, 3, 1, 4, 6]","Nếu như các truy vấn chỉ yêu cầu ta tìm GTNN của các đoạn thì bảng thưa là một lựa chọn phù hợp để giải quyết bài toán. Tuy nhiên nếu bài toán có thêm các truy vấn yêu cầu thay đổi giá trị của các phần tử trong mảng, thì ta cần phải cập nhật phần tử và xây dựng lại bảng thưa, khiến cho bảng thưa không còn hiệu quả.","Ta sẽ nói về CTDL Cây phân đoạn (Segment Tree)- một CTDL linh hoạt giúp giải quyết bài toán này."]},{"l":"Tư tưởng","p":["Giả sử bạn muốn đo chiều cao của tất cả học sinh trong một khu vực.","Một điều chắc chắn là ta không thể đến và đo chiều cao của tất cả học sinh trong khu vực ấy được - nó tốn quả nhiều thời gian và không hề hiệu quả. Thay vì thế, ta có thể bàn giao công việc này cho các trường trong khu vực, mỗi trường đó lại để giáo viên chủ nhiệm đo chiều cao của các em học sinh trong lớp và báo cáo lại để nhà trường tổng hợp lại.","Khi này, thay vì kiểm tra tất cả học sinh ấy thì ta chỉ cần thu thập thông tin tổng hợp từ các trường. Điều này giúp ta thu thập thông tin nhanh hơn và hiệu quả hơn.","Đây chính là ý tưởng chính cho CTDL Segment Tree: Chia một không gian quản lí lớn thành các không gian quản lí nhỏ hơn - một giải pháp chia để trị."]},{"l":"Segment Tree","p":["Segment tree là một cây, chính xác hơn là một cây nhị phân đầy đủ - mỗi đỉnh hoặc là một đỉnh lá hoặc có hai đỉnh con. Ta sẽ lưu segment tree trên một mảng st với chỉ số 1 đại diện cho gốc của cây. Với mỗi chỉ số p, 2 \\times p và 2 \\times p + 1 là hai chỉ số của hai đỉnh con của nó.","Mỗi đỉnh của cây sẽ lưu thông tin về một phân đoạn trên mảng a. Gốc của Segment Tree tượng trưng cho đoạn [1, n]. Với mỗi đỉnh p lưu thông tin về đoạn [l, r]. Nếu p không phải là đỉnh lá thì hai đỉnh con 2 \\times p và 2 \\times p + 1 sẽ lần lượt lưu thông tin của hai đoạn [l, \\left\\lfloor (l + r) / 2 \\right\\rfloor] và [\\left\\lfloor(l + r) / 2\\right\\rfloor + 1, r]. Nếu p là đỉnh lá thì nó chỉ quản lý đúng một phần tử duy nhất trên mảng a có chỉ số l = r."]},{"l":"Xây dựng segment tree","p":["Để xây dựng segment tree, ta có hàm đệ quy build(p, l, r).","Hàm build(p, l, r) của ta hoạt động như sau:","Nếu l = r, giá trị nhỏ nhất của đoạn [l, r] chính là phần tử a[l]: st[p] = a[l].","Nếu l \\neq r, ta sẽ tính một cách đệ quy GTNN của hai đỉnh con và tính giá trị của đỉnh p từ giá trị của hai đỉnh con: st[p] = min(st[p \\times 2], st[p \\times 2 + 1]).","Ta xây dựng segment tree bằng cách gọi build(1, 1, n).","Segment Tree Build","Ta có thể thấy số lượng đỉnh cần tính sẽ là độ phức tạp của việc xây dựng segment tree. Ta có thể tính được số lượng đỉnh trong segment tree sẽ không vượt quá 4n, nên độ phức tạp thuật toán và không gian sẽ bằng O(4n) \\approx O(n)."]},{"l":"Trả lời truy vấn","p":["Ta xử lí các truy vấn yêu cầu ta tìm GTNN của một đoạn [l, r] bằng cách sử dụng các đoạn đã được tính trước.","Giả sử ta đang ở đỉnh p lưu GTNN của đoạn [u, v], ta sẽ tính kết quả như sau:","Nếu [u, v] nằm hoàn toàn bên trong [l, r]( l \\le u \\le v \\le r), ta trả về GTNN lưu trong đỉnh p.","Nếu [u, v] nằm hoàn toàn bên ngoài [l, r]( v < l hoặc r < u), ta bỏ qua GTNN lưu trong p.","Nếu một phần [u, v] nằm bên trong [l, r], ta sẽ tính được GTNN từ hai đỉnh con bằng cách áp dụng các bước ở trên và kết hợp GTNN trả về từ hai đỉnh ấy.","Ta tính GTNN của đoạn [l, r] bằng việc xuất phát từ đỉnh 1 và thực hiện các bước ở trên","Hình dưới đây minh họa thao tác trả lời truy vấn tìm GTNN của đoạn [3, 7].","Segment Tree Answer","Sau khi thực hiện tìm GTNN, thuật toán của ta trả về GTNN của các đoạn [3, 4], [5, 6] và [7, 7] có GTNN lần lượt là 7, 1 và 4. Kết hợp các kết quả này lại và ta có kết quả của đoạn [3, 7] bằng min([3, 7]) = min([3, 4], [5, 6], [7, 7]) = min(7, 1, 4) = 1.","Để tìm GTNN của phân đoạn [l, r], ta gọi ans(1, 1, n, l, r).","Độ phức tạp thuật toán sẽ là O(\\log{n})."]},{"l":"Cập nhật giá trị"},{"l":"Cập nhật điểm","p":["Đối với các truy vấn yêu cầu ta thay đổi giá trị của một phần tử trong mảng, ta cập nhật phần tử ấy và tính toán lại các phân đoạn phụ thuộc vào phần tử đó.","Segment Tree Point Update","Để cập nhật giá trị của phần tử thứ i thành x, ta gọi update(1, 1, n, i, x).","Thuật toán của ta sẽ đi qua số lượng đỉnh bằng với chiều cao của cây nên có độ phức tạp O(\\log{n})."]},{"l":"Cập nhật đoạn","p":["Đối với cập nhật đoạn, ta cần một cách xử lí thông minh hơn.","Giả sử ta áp dụng cách cập nhật đoạn tương tự cách làm với cập nhật điểm, số lượng phân đoạn ta cần cập nhật có thể lên đến O(n).","Nếu ta cập nhật: \"thay đổi các phần tử trong khoảng [2, 7] thành 9\":","Segment Tree Range Update","Có thể thấy thao tác cập nhật O(n) này thì sẽ không hề hiệu quả. Vậy làm sao để khắc phục nhược điểm này?"]},{"l":"Cập nhật lười","p":["Cập nhật lười, hay lazy propagation, là một kĩ thuật giúp ta thực hiện truy vấn cập nhật đoạn hiệu quả trên segment tree.","Giả sử ta thực hiện cập nhật phân đoạn trên một đỉnh, ta sẽ lưu cập nhật này và không cập nhật đỉnh ấy.","Lazy Propagation","Chỉ khi đỉnh này được xét đến thì ta mới thực hiện cập nhật giá trị trên đỉnh ấy mà ta đã lưu. Sau khi cập nhật xong thì ta lưu cập nhật lên các đỉnh con và xóa thông tin cập nhật trên đỉnh này.","Lazy Propagation Applied","Bằng cách này, ta có thể giảm số lượng đỉnh mà ta cần đến khi cập nhật.","Seg,emt Tree Lazy Propagation","Để cập nhật giá trị của các phần tử từ l đến r thành x, ta gọi update(1, 1, n, l, r, x).","Độ phức tạp của truy vấn cập nhật đoạn giờ đây giảm xuống còn O(\\log{n}).","Ta cũng cần sửa lại hàm ans khi áp dụng cập nhật lười.","Độ phức tạp của hàm ans không thay đổi: O(\\log{n})."]}],[{"i":"cây-chỉ-số-nhị-phân---cây-fenwick-fenwick-tree","l":"Cây chỉ số nhị phân - Cây Fenwick (Fenwick Tree)","p":["Cây chỉ số nhị phân (Binary Index Tree) hay cây Fenwick (Fenwick Tree) là một CTDL giúp ta trả lời các truy vấn trên đoạn một cách hiệu quả. Mặc dù không \"mạnh\" bằng Segment Tree nhưng CTDL này vẫn được sử dụng thường xuyên trong lập trình thi đấu vì có thể cài đặt nhanh và đơn giản hơn so với Segment Tree."]},{"l":"Tư tưởng","p":["Ta sẽ bắt đầu với bài toán sau:","Cho một mảng a có n phần tử và q truy vấn có dạng (l, r). Với mỗi truy vấn, tìm và in ra tổng của các phần tử trong khoảng [l, r]. Chỉ số của mảng a bắt đầu từ 1.","a = [1, 5, 8, 2, 7, 3, 4, 6]","Nếu như giá trị của mảng không thay đổi thì ta có thể dễ dàng giải quyết bài toán bằng cách tạo một mảng T với T[0] = 0, T[1] = a[1] và T[i] = T[i - 1] + a[i] với mọi i lớn hơn 1(mảng T này còn được gọi là mảng cộng dồn).","$T = [1, 6, 14, 16, 23, 26, 30, 36] $","Khi này, ta có thể tính tổng các phần tử trong khoảng [l, r] bằng công thức: query(l, r) = T[r] - T[l - 1].","Việc xây dựng mảng T có độ phức tạp O(n) và các truy vấn là O(1).","Tuy nhiên, nếu bài toán có các truy vấn yêu cầu ta cập nhật giá trị của một phần tử trong mảng (ví dụ như tăng giá trị của a[i] lên x) thì ta cần phải cập nhật giá trị ấy và xây dựng lại mảng T từ đầu đến cuối - một điều không hiệu quả nếu bài toán có nhiều truy vấn cập nhật giá trị.","Một ý tưởng tối ưu đó chính là ta chia mảng T thành hai đoạn con nhỏ hơn T1 và T2- đoạn T1 sẽ tính cộng dồn một nửa các phần tử đầu tiên trong mảng a, đoạn T2 sẽ tính cộng dồn các phần tử còn lại.","$T_1 = [1, 6, 14, 16], T_2 = [7, 10, 14, 20] $","Bằng cách này, khi cập nhật giá trị, ta chỉ cần tính lại một trong hai đoạn T1 hoặc T2.","Cốt lõi của cây Fenwick sẽ sử dụng ý tưởng này."]},{"l":"Cây Fenwick","p":["Mặc dù có tên gọi là \"cây\" Fenwick nhưng CTDL này lại được biểu diễn trên một mảng dữ liệu.","Ta có mảng ft, ft[i] sẽ lưu tổng của các phần tử có chỉ số nằm trong khoảng [i - LSB(i) + 1, i], với hàm LSB(i) trả về giá trị bit nhỏ nhất của i. Ví dụ ft[6] có giá trị bằng tổng của a[5] và a[6].","Từ đây ta có mảng ft được xây dựng từ mảng a:","Fenwick","Ta sẽ sử dụng cây Fenwick vừa xây dựng để tìm kiếm đáp án."]},{"i":"hàm-sumi","l":"Hàm sum(i)","p":["Ta có hàm sum(i) tính tổng các phần tử từ 1 đến i:","Ta cũng có thể viết hàm sum(i) bằng cách sử dụng vòng lặp for:","Hàm sum(i) này giúp ta có thể tính toán hiệu quả tổng của i số đầu tiên trong mảng a. Từ đây ta có thể tính query(l, r) = sum(r) - sum(l - 1).","Vì với mỗi thao tác ta xóa LSB(i) khỏi i nên độ phức tạp của hàm sum bằng O(\\log{n}).","Thực tế trong hầu hết trường hợp số thao tác mà sum(i) thực hiện sẽ nhỏ hơn \\log{i} do không phải lúc nào i cũng có \\log{i} bit được bật."]},{"i":"hàm-updatei-x","l":"Hàm update(i, x)","p":["Ta có hàm update(i, x) tăng giá trị của phần tử a[i] lên x:","Tương tự với sum(i), độ phức tạp của update(i, x) là O(\\log{n})."]},{"l":"Xây dựng mảng ft","p":["Để xây dựng mảng ft cho cây Fenwick, ta có thể áp dụng 1 trong 2 phương pháp:","Phương pháp 1: gán ft[i] = 0 với mọi i từ 1 đến n. Duyệt từ 1 đến n, gọi hàm update(i, a[i]).","Phương pháp 1 có độ phức tạp O(n\\log{n}).","Phương pháp 2: gán ft[i] = a[i] với mọi i từ 1 đến n. Duyệt từ 1 đến n, nếu i + LSB(i) \\le n, cập nhật ft[i + LSB(i)] += ft[i].","Phương pháp 2 có độ phức tạp O(n)."]}],[{"l":"Disjoint Set Union"},{"l":"Định nghĩa","p":["CTDL Disjoint Sets Union (DSU) hay với tên gọi khác là Union-Find Disjoint Sets (UFDS) là một CTDL quản lí các tập hợp không giao nhau, tức là các tập hợp không có phần tử chung. CTDL này có thể trả lời hiệu quả nếu 2 phần tử có nằm trong cùng một tập hợp hay không, hoặc hợp 2 tập hợp lại với nhau.","Như tên gọi của mình, DSU bao gồm các thao tác chính:","MakeSet: Tạo một tập hợp có 1 phần tử là a.","Union: Hợp tập hợp chứa phần tử a và tập hợp chứa phần tử b thành một tập hợp, và","Find: Tìm phần tử đại diện của tập hợp chứa phần tử a.","Mỗi tập hợp sẽ có một phần tử làm phần tử đại diện, dùng để xác định tập hợp mà nó nằm trong. Đây cũng là giá trị trả về của thao tác Find.","Để kiểm tra nếu 2 phần tử có nằm trong cùng một tập hợp không thì ta kiểm tra nếu Find(a) = Find(b) hay nếu tập hợp chứa a và tập hợp chứa b đều có cùng một phần tử đại diện."]},{"l":"Cài đặt","p":["Để cài đặt DSU, ta có mảng p có n phần tử dùng để lưu các phần tử đại diện của tập hợp - ví dụ: p[i] lưu phần tử đại diện của tập hợp chứa i.","Ta có cài đặt DSU bằng Quick-Find:","MakeSet(a) và Find(a) có độ phức tạp O(1), còn Union(a, b) là O(n).","Như ta có thể thấy, hàm Union có độ phức tạp thời gian quá lớn. Tuy nhiên, ta cũng có nhiều cách để tối ưu nó."]},{"l":"Tối ưu DSU"},{"l":"Quick-Union","p":["Ta sẽ tối ưu hàm Union bằng cách mô tả các tập hợp bằng các đồ thị cây hay rừng cây. p[i] giờ đây sẽ chỉ cha của đỉnh i trong đồ thị cây. Khi thực hiện Union(a, b) ta chỉ cần thay đổi cha của gốc của cây chứa a thành gốc của cây chứa của b hay p[Find(a)] = Find(b). Và khi thực hiện Find(a) ta tìm gốc của cây bằng cách xét dãy a, p[a], p[p[a]], ... cho tới khi tìm tìm được phần tử trong dãy có giá trị giống phần tử trước nó, tức là ta đã tìm được gốc của cây.","Thao tác","Minh họa","Ban đầu","Union(1, 2)","Union(2, 3)","Union(1, 4)","Lúc này độ phức tạp của Find là O(n) và Union là O(n).","Vì sao Find lại là O(n)? Giả sử việc Union sẽ tạo thành một cây được nối thành một đường thẳng. Khi đó việc Find sẽ có độ phức tạp O(n). Và cũng vì trong Union có sử dụng Find nên độ phức tạp của Union cũng là O(n).","Tuy vậy, cách thực hiện Union của Quick-Union vẫn nhanh hơn Union của Quick-Find. Union của Quick-Find thì duyệt các phần tử trong p, còn Union của Quick-Union thì phụ thuộc vào chiều cao của cây. Trên trung bình, các cây được tạo bởi Quick-Union có độ cao khá bé nên nó nhanh hơn Quick-Find."]},{"l":"Tối ưu Union","p":["Như đã nói ở trên, trên trung bình, các cây có độ cao tương đối nhỏ. Dẫu vậy, làm cách nào để ta đảm bảo được chiều cao của các cây ấy đều nhỏ trong mọi trường hợp? Ta sẽ thay đổi cách thực hiện hàm Union."]},{"l":"Union theo thứ hạng","p":["Ta có Union theo thứ hạng: Khi Union tập hợp chứa a và tâp hợp chứa b, cây nào có thứ hạng cao hơn sẽ là cha của cây có thứ hạng thấp hơn, nếu 2 cây có thứ hạng bằng nhau thì gốc của đỉnh nào làm cha cũng được, nhưng thứ hạng của cây có đỉnh được chọn phải tăng thêm 1.","Ta sẽ tạo một mảng r lưu thứ hạng của tập hợp chứa đỉnh i. Ban đầu, các giá trị trong r sẽ bằng 0.","Hàm Find sẽ tương tự với Find trong Quick-Union.","Ta có giả thiết: Một cây có thứ hạng k sẽ có ít nhất 2^{k} đỉnh.","Chứng minh: Nếu k bằng 0, thì điều này là chính xác vì khi cây có thứ hạng bằng 0 thì chỉ có 1 đỉnh. Ta cũng nhận thấy rằng để có cây có thứ hạng k thì nó phải được Union theo thứ hạng từ 2 cây có thứ hạng k - 1, khi đó số đỉnh trong cây có thứ hạng k sẽ lớn hơn hoặc bằng 2^{k - 1} + 2^{k - 1} = 2^k.","Từ đây ta có thể nhận định rằng thứ hạng cao nhất có thể khi liên tiếp thực hiện Union theo thứ hạng n phần tử là \\log{n}."]},{"l":"Union theo kích thước","p":["Ta có Union theo kích thước: Khi Union tập hợp chứa a và tâp hợp chứa b, cây có nhiều đỉnh hơn sẽ là cha của gốc của cây có ít đỉnh hơn, nếu 2 cây có số lượng đỉnh bằng nhau thì lấy cây nào làm cha cũng được.","Ta sẽ tạo một mảng sz lưu kích thước của tập hợp chứa đỉnh i. Ban đầu, các giá trị trong sz sẽ bằng 1.","Hàm Find sẽ tương tự với Find trong Quick-Union.","Tương tự với Union theo thứ hạng, ta có giả thiết: Một đỉnh x bất kì sẽ không có chiều cao quá \\log{n}.","Chứng minh: Chiều cao của đỉnh x nằm trong cây T_1 sẽ không thay đổi trừ khi được hợp lại với cây T_2 có kích thước lớn hơn T_1.","Khi này:- Chiều cao của x tăng lên 1- Kích thước của cây mới T_3 chứa đỉnh x sẽ gấp đôi cây cũ hoặc hơn: size(T_3) = size(T_1) + size(T_2) \\ge 2 \\times size(T_1)","Giống với Union theo thứ hạng, ta có thể nhận định rằng chiều cao lớn nhất có thể khi liên tiếp Union theo thứ hạng n phần tử là \\log{n}.","Bằng việc áp dụng Quick-Union với Union theo kích thước/thứ hạng, ta có thể đảm bảo rằng chiều cao của cây sẽ không vượt quá \\log{n} và độ phức tạp cho Find và Union sẽ giảm xuống còn O(\\log{n})."]},{"l":"Tối ưu Find","p":["Việc áp dụng cách cài đặt Quick-Union đã làm gia tăng độ phức tạp của hàm Find, nhưng không vì thế mà ta không có cách tối ưu nó."]},{"l":"Kĩ thuật nén đường đi","p":["Kĩ thuật nén đường đi rất đơn giản: Khi đã tìm được gốc của cây bằng dãy a, p[a], p[p[a]],... như ở phần Quick-Union, gán cha của tất cả các phần tử trong dãy đó thành gốc đã tìm được.","Hàm Find này chạy rất nhanh, với độ phức tạp O(\\log^* n) trên trung bình nếu kết hợp với Union theo thứ hạng/kích thước hoặc O(\\log{n}) nếu sử dụng đơn lẻ.","\\log^* n hay logarit lặp là số lần áp dụng hàm \\log_2 với chính nó cho tới khi giá trị đạt được không lớn hơn 1.","VD: 65536 = 2^{16} \\rightarrow 16 = 2^4 \\rightarrow 4 = 2^2 \\rightarrow 2 \\rightarrow 1 \\implies log^* 65536 = 4","Vì trong hầu hết các trường hợp, \\log^* n rất nhỏ nên ta coi nó như O(1)."]},{"l":"Tổng hợp các cách cài đặt DSU","p":["Bảng dưới đây so sánh độ phức tạp thời gian của 2 hàm Find và Union của các cách cài đặt DSU được nói ở trên:","Tên gọi","Find","Union","Quick-Find","O(1)","O(n)","Quick-Union","Quick-Union theo kích thước/thứ hạng","O(\\log{n})","Quick-Union + nén đường đi","Quick-Union theo kích thước/thứ hạng + nén đường đi","O(log^* n)"]}],[{"l":"Duyệt toàn bộ","p":["Duyệt toàn bộ (Complete search), hay với các tên gọi khác như duyệt trâu, vét cạn, brute force, là một mô hình thuật toán. Các thuật toán duyệt toàn bộ sẽ giải quyết bài toán bằng cách kiểm tra (gần như) toàn bộ không gian tìm kiếm của bài để tìm kiếm kết quả thỏa mãn, ví dụ như kiểm tra các phần tử, các cặp giá trị, các tập con, hoán vị, v.v.","Ưu điểm của duyệt toàn bộ là luôn đảm bảo tìm ra nghiệm đúng, chính xác. Tuy nhiên, thời gian thực thi lại lâu, độ phức tạp lớn.","Trong các cuộc thi lập trình, các thí sinh có xem xét việc cài đặt thuật toán theo mô hình duyệt toàn bộ khi không thể tìm ra thuật toán khác tốt hơn. Bằng cách này, thí sinh có thể giành điểm ở những subtask đầu tiên - các subtask dễ và có thể giải được bằng duyệt toàn bộ (nếu có). Ngoài ra, thí sinh cũng có thể cài đặt thuật toán duyệt toàn bộ kể cả khi tồn tại thuật toán tối ưu hơn nếu giới hạn của bài toán đủ nhỏ.","Đôi khi, việc chạy thuật toán duyệt toàn bộ trên một số test nhỏ có thể giúp ta hiểu được bản chất của bài toán dễ dàng hơn, giúp tăng khả năng tìm được thuật toán chuẩn của bài."]},{"l":"Sinh tập con","p":["Ta xem xét các bài toán yêu cầu ta sinh ra tất cả các tập con của danh sách n phần tử. Ví dụ với danh sách 3 phần tử thì ta sẽ có các tập con chứa chỉ số của các phần tử (bắt đầu tử chỉ số 0):","\\emptyset, \\\\{0\\\\}, \\\\{1\\\\}, \\\\{2\\\\}, \\\\{0, 1\\\\}, \\\\{0, 2\\\\}, \\\\{1, 2\\\\}, \\\\{0, 1, 2\\\\}.","Ta có thể sử dụng đệ quy để sinh các tập con.","Ta có thể sử dụng bitmask để xét các tập con.","Ví dụ: 5_{10} = 101_2 biểu thị tập hợp {0, 2}.","Ta duyệt các số từ 0 đến 2^n - 1, tương đương với duyệt các tập con của tập hợp n phần tử","Ta cũng có thể sử dụng cách duyệt khác với khả năng tương tự.","Có nhiều nhất n phần tử cho mỗi tập con nên độ phức tạp khi sinh và xét các tập con sẽ là O(2^n \\times n). Nếu ta có thể vừa xét vừa duyệt các tập con đối với phương thức đệ quy thì có thể giảm xuống thành O(2^n)."]},{"l":"Sinh hoán vị","p":["Ta xem xét các bài toán yêu cầu ta sinh ra tất cả các hoán vị của danh sách n phần tử. Ví dụ với danh sách 3 phần tử thì ta sẽ có các hoán vị chứa chỉ số của các phần tử (bắt đầu tử chỉ số 0):","\\\\{0, 1, 2\\\\}, \\\\{0, 2, 1\\\\}, \\\\{1, 0, 2\\\\}, \\\\{1, 2, 0\\\\}, \\\\{2, 0, 1\\\\}, \\\\{2, 1, 0\\\\}.","Ta có thể sử dụng đệ quy:","hoặc có thể sử dụng hàm next_permutaion để xét các hoán vị.","Có n phần tử cho mỗi hoán vị nên độ phức tạp cho cả hai cách là O(n! \\times n)."]},{"l":"Quay lui"},{"l":"Bài toán 8 quân hậu"},{"l":"Chia đôi tập"}],[{"l":"Tham lam","p":["Greed is good. Greed is right. Greed works. Greed clarifies, cuts through, and captures the essence of the evolutionary spirit.- Gordon Gecko","Pending"]}],[{"l":"Chia để trị","p":["\"Divide et impera. Veni, vidi, vici\" - Julius Caesar","Chia để trị (Divide and Conquer) là một mô hình thuật toán. Một thuật toán áp dụng mô hình chia sẽ trị sẽ giải quyết bài toán bằng cách chia bài toán thành các bài toán nhỏ hơn (thường là chia làm đôi). Từ những bài toán nhỏ hơn này ta kết hợp các đáp án của chúng lại với nhau để tìm được đáp án của bài toán ban đầu.","Giống như khi ta đọc và nhớ một số điện thoại, ta không nhớ một lúc 10 chữ số xxxxxxxxx mà ta chia nó ra thành 3 phần nhỏ hơn xxxx-xxx-xxx để dễ ghi nhớ.","Ta đã được thấy mô hình này được áp dụng ở các thuật toán như tìm kiếm nhị phân, merge sort, quicksort, trong các CTDL như segment tree."]},{"l":"Tư tưởng","p":["Một thuật toán áp dụng chia để trị có 3 bước chính:","Chia: Chia nhỏ bài toán thành các bài toán con.","Trị: Giải các bài toán con. Nếu bài toán nhỏ ấy đủ nhỏ, ta sẽ tìm đáp án của bài toán nhỏ ấy. Nếu không thì giải bài toán con một cách đệ quy.","Hợp: Kết hợp các đáp án của các bài toán con để cho ra đáp án của bài toán ban đầu."]},{"l":"Merge Sort","p":["Ta đã được thấy mô hình chia để trị qua thuật toán merge sort.","Ta có một mảng 8 phần tử:","Mảng chứa 8 phần tử","Thuật toán sẽ bao gồm các bước:","Chia: Thuật toán chia mảng thảnh hai mảng con.","Trị: Sắp xếp các mảng con một cách đệ quy bằng Merge sort.","Mảng chia thành 2 mảng con","Hợp: Gộp các mảng con lại với nhau (có thể hợp một cách hiệu quả bằng hai con trỏ).","Hợp các mảng con"]},{"l":"Độ phức tạp thuật toán","p":["Để tính độ phức tạp của các thuật toán áp dụng mô hình chia để trị, ta tiến hành phân tích thuật toán bằng định lí Master.","Giả sử T(n) là số thao tác cần thực hiên của một thuật toán, ta có:","T(n) = aT(n / b) + f(n)","với n là kích thước của dữ liệu, hai hằng số a, b lần lượt là số bài toán con và tỉ lệ kích thước dữ liệu của bài toán gốc và bài toán con, còn hàm f(n) chính là số thao tác để thực hiện việc chia bài toán và hợp các bài toán con.","Sử dụng công thức này, có thể tích được độ phức tạp của các thuật toán. Ví dụ với thuật toán Merge Sort thì ta có: T(n) = 2T(n / 2) + O(n), từ đây suy ra độ phức tạp sẽ là O(n \\log{n}).","Có thể xem thông tin về định lí Master tại các nguồn tài liệu khác để hiểu thêm."]},{"l":"Phần tử nhỏ thứ k","p":["Bài toán: Cho một mảng a có n phần tử. Hãy tìm và in ra giá trị của phần tử nhỏ thứ k trong mảng (các phần tử bắt đầu từ 1).","VD: Phần tử nhỏ thứ 3 của mảng a = [18, 43, 6, 15, 9, 37, 10, 42] có giá trị bằng 10.","Ta có thể sắp xếp lại các phần tử trong mảng bằng một thuật toán sắp xếp nào đấy ( QuickSort- O(n\\log{n})) và in ra phần tử thứ k trong mảng.","Độ phức tạp của thuật toán sẽ là O(n\\log{n}).","Tuy nhiên, ta có thể xử lý bài toán với độ phức tạp O(n) một cách đơn giản bằng cách áp dụng mô hình chia để trị và có phần giống với QuickSort.","Thuật toán của ta sẽ chọn một phần tử ngẫu nhiên trong mảng a[p] và sắp xếp lại các phần tử trong mảng a: các phần tử a[x] \\le a[p] sẽ được xếp bên trái a[p], các phần tử còn lại sẽ được xếp ở bên phải a[p]. Gọi chỉ số của phần tử a[p] sau khi sắp xếp lại mảng a là q, ta có 3 trường hợp có thể xảy ra:","Trường hợp 1: q = k: a[q] chính là đáp án của bài toán. Ta trả về giá trị cần tìm và kết thúc thuật toán.","Trường hợp 2: q \\lt k: Đáp án của bài toán sẽ nằm ở bên trái a[q], hay các phần tử có chỉ số trong khoảng [1..q - 1].","Trường hợp 3: q \\gt k: Đáp án của bài toán sẽ nằm ở bên phải a[q], hay các phần tử có chỉ số trong khoảng [q + 1..n].","Các trường hợp 2 và 3 sẽ được thuật toán xử lý một cách đệ quy cho tới khi tìm được đáp án.","Độ phức tạp thuật toán này sẽ là O(n).","Trong thư viện C++ tồn tại hàm nth_element có thể giải quyết bài toán này và cũng áp dụng thuật toán như trên."]},{"l":"Cặp điểm gần nhất","p":["Bài toán: Cho n điểm trên Hệ tọa độ Descartes. Tìm và in ra cặp điểm có khoảng cách Euclid nhỏ nhất. (Khoảng cách Euclid của hai điểm (x_1, y_1), (x_2, y_2) là \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}).","Chắc hẳn bạn sẽ có nghĩ rằng liệu như thế này có phải quá dễ không? Bạn nghĩ đúng rồi đấy!","Chia: Sắp xếp các điểm theo tọa độ x, tìm phần tử ở giữa midpoint và chia các điểm thành hai phần - phần bên trái là các điểm có tọa độ x nhỏ hơn hoặc bằng midpoint, phần bên phải là các điểm có tọa độ x lớn hơn midpoint.","Có! Ta hoàn toàn có thể đạt được độ phức tạp O(n\\log{n}) nếu ta sắp xếp trước các điểm theo tọa độ y thay vì sắp xếp các đỉnh ấy sau mỗi lần thực hiện chia để trị.","Đầu tiên, ta xét các điểm có khoảng cách với đường thẳng song song với trục Oy đi qua midpoint nhỏ hơn \\delta. Ta cho các đỉnh vào một danh sách.","Độ phức tạp của thuật toán sẽ là O(n\\log{n}).","Hợp: Trả về min(\\delta_1, \\delta_2).","Một thuật toán đơn giản sẽ giải quyết bài toán này bằng cách xét tất cả các cặp điểm và tìm khoảng cách nhỏ nhất giữa các cặp điểm ấy. Độ phức tạp của thuật toán khi này sẽ là O(n^2).","Ở ví dụ trên, hai điểm được tô màu đỏ sẽ cho ta cặp điểm có khoảng cách nhỏ nhất.","Sau đó, sắp xếp các đỉnh trong danh sách theo tọa độ y và bắt đầu tìm cặp điểm nhỏ nhất đối với các đỉnh này.","T(n) = 2T(n / 2) + O(n\\log{n}) \\rightarrow T(n) = O(n \\log^2{n})","Ta có thể chứng minh được rằng với mỗi đỉnh ta đang xét, ta chỉ cần kiểm tra nhiều nhất 6 đỉnh (người đọc tự chứng minh).","Ta có thể tính được độ phức tạp của thuật toán này bằng định lí master. Ta có:","Ta có: \\delta = min(\\delta_1, \\delta_2).","Thay vì phải tốn thời gian xét tất cả cặp điểm - điều sẽ khiến thuật toán của ta chạy chậm hẳn đi thành O(n^2), ta sẽ chỉ xét các điểm đặc biệt.","Thuật toán của ta sẽ bao gồm các bước như sau:","Thuật toán ở trên của ta là một thuật toán sai, cụ thể là ở phần hợp. Ta quên xét đến trường hợp nếu một điểm bên trái và một điểm bên phải có thể hình thành cặp điểm có khoảng cách Euclid nhỏ nhất.","Trị: Tìm khoảng cách Euclid nhỏ nhất đối với hai đỉnh bất kì với mỗi bên: \\delta_1 là khoảng cách Euclid nhỏ nhất của các điểm bên trái, \\delta_2 cho các đỉnh bên phải.","Tuy nhiên, áp dụng mô hình chia để trị sẽ giúp ta viết ra được một thuật toán hiệu quả hơn!"]}],[{"l":"Quy hoạch động","p":["Pending"]}],[{"l":"Quy hoạch động chữ số","p":["Quy hoạch động chữ số hay Digit DP chỉ các bài toán sử dụng quy hoạch động liên quan đến các chữ số."]},{"l":"Lý thuyết","p":["Các bài QHĐ chữ số sẽ có mô tả như sau: Cho một khoảng số [a, b], hãy đếm số lượng số trong khoảng thỏa mãn yêu cầu đề bài.","Gọi G(X) là số lượng số nằm trong khoảng [0, X] thỏa mãn yêu cầu đề bài. Khi này ta có thể tính được đáp án của bài toán bằng công thức: G(b) - G(a - 1) hoặc G(b) - G(a) + g(a) với g(x) là một hàm trả về 1 nếu x thỏa mãn yêu cầu và 0 nếu không thỏa mãn."]},{"i":"xây-dựng-hàm-","l":"Xây dựng hàm G(X)","p":["Để xây dựng hàm G(X), ta sẽ xem các số trong khoảng [0, X] như một xâu kí tự: Ta có X = \\overline{x_{n - 1}x_{n - 2}...x_{0}} với n là số chữ số trong X. Ta sẽ tạo các số A = \\overline{a_{n - 1}a_{n - 2}...a_{0}} nhỏ hơn hoặc bằng X, và ta thực hiện việc gán giá trị cho các chữ số của A theo chiều từ trái sang phải.","Giả sử ta có X = 3141:","x_3","x_2","x_1","x_0","3","1","4","Ta thực hiện việc gán giá trị cho phần tử a_i:"]},{"l":"Trường hợp không giới hạn","p":["Giả sử ta đã điền các chữ số ở trước a_1 bằng các giá trị sau:","a_3","a_2","a_1","a_0","2","1","\\*","Trường hợp không giới hạn sẽ xảy ra nếu các số được điền trước a_i có thứ tự từ điển nhỏ hơn hẳn X. Khi này, ta có thể điền a_i các chữ số từ 0 đến 9.","Ở đây, vì 21 < 31 nên a_1 rơi vào trường hợp không giới hạn. Vì vậy ta được quyền gán cho a_1 các chữ số từ 0 đến 9. Ta có thể kết luận như vậy vì dù có gán a_1 bằng chữ số nào đi nữa thì các số có dạng \\overline{21**} cũng sẽ nhỏ hơn X."]},{"l":"Trường hợp có giới hạn","p":["\\*","1","2","a_0","a_1","a_2","a_3","D là hệ số của số đang xét.","Độ phức tạp của QHĐ chữ số thường sẽ có dạng: O(D \\times 2 \\times n \\times S_1 \\times S_2 \\times ... \\times S_k), trong đó:","f(idx, smaller, S_1, S_2, ..., S_k)","G(X) = f(n - 1, 0, S_1, S_2, ..., S_k)","Giả sử ta đã điền các chữ số ở trước a_1 bằng các giá trị sau:","idx là chỉ số ta cần điền","Khi này, ta sẽ gọi hàm f để tính G(X):","n là số chữ số của X.","Ở đây, ta có 31 là một tiền tố của X nên rơi vào trường hợp có giới hạn. Ta chỉ có thể gán cho a_1 các chữ số từ 0 đến x_1 = 4. Giả sử ta gán a_1 = 5. Khi này, các số có dạng \\overline{315*} sẽ có giá trị lớn hơn X, và các số có dạng này là các số mà ta không cần xét đến.","S_1, S_2, ...,S_k là các tính chất của đoạn số \\overline{a_{n - 1}a_{n - 2}...a_{idx + 1}}.","smaller = 0 nếu rơi vào trường hợp có giới hạn.","smaller = 1 nếu rơi vào trường hợp không giới hạn.","smaller bằng 0/1 với ý nghĩa:","Ta cùng xem qua một số bài toán ví dụ để hiểu rõ hơn.","Trong đó:","Trường hợp không giới hạn sẽ xảy ra nếu các số được điền trước a_i là một tiền tố của số X. Khi này, ta chỉ có thể điền a_i các chữ số từ 0 đến x_i.","Từ 2 trường hợp trên, ta có các trạng thái QHĐ cần thiết để giải một bài toán QHĐ chữ số:"]},{"l":"Một số bài toán ví dụ"},{"i":"ví-dụ-1-digitsum-fct003_digitsum","l":"Ví dụ 1: DIGITSUM (FCT003_DIGITSUM)","p":["Chuyển trạng thái:","Đề bài: Free Contest Testing Round 3 - DIGITSUM","Độ phức tạp của thuật toán này là O(10 \\times n \\times 2 \\times sum).","Giả sử ta đã điền được số cho a_{idx}, ta sẽ bắt đầu điền số tiếp theo.","Giới hạn: 0 \\le a \\le b \\le 10^{15}.","idx' = idx - 1.","Khi ta ở trạng thái (idx, smaller, sum):","Nếu idx = -1, ta không còn vị trí nào để điền giá trị, từ đấy ta trả về giá trị sum. Nếu idx lớn hơn -1, ta sẽ thực hiện gán giá trị cho a_{idx}.","Nếu smaller = 0 thì smaller' = 1 nếu v < limit, smaller' = 0 nếu v = limit.","Nếu smaller = 1 thì smaller' = 1.","Nếu trạng thái của ta đang là (idx, smaller, sum), và ta điền a_{idx} = v, ta sẽ chuyển trạng thái tiếp theo (idx', smaller', sum'):","Ngoài cách giải QHĐ chữ số, ta cũng có thể giải theo phương pháp khác.","smaller':","sum' = sum + v.","Ta có các trạng thái QHĐ: (idx, smaller, sum) với idx, smaller có định nghĩa như trên và sum là tổng của các chữ số đã điền.","Ta có thể điền các số từ 0 đến limit cho số a_{idx}, với limit = 9 nếu smaller = 1, hoặc limit = x_{idx} nếu smaller = 0.","Tính giá trị:","Tóm tắt: Cho hai số nguyên không âm a và b, tính tổng chữ số của các số trong đoạn [a, b].","Ví dụ:[49; 52] = 4 + 9 + 5 + 0 + 5 + 1 + 5 + 2 = 31."]},{"i":"ví-dụ-2-digit-sum-atcoder-educational-dp-contest-s","l":"Ví dụ 2: Digit Sum (Atcoder Educational DP Contest S)","p":["Đề bài: Atcoder Educational DP Contest S - Digit Sum","Tóm tắt: Cho hai số K và D, đếm số lượng số từ 1 đến K có tổng chữ số chia hết cho D, modulo 10^9 + 7.","Giới hạn: 1 \\le K \\lt 10^{10000}, D \\lt 100.","Bài toán này tương tự với bài toán ở ví dụ 1, có 3 trạng thái QHĐ (idx, smaller, sum) nhưng có một chút khác biệt.","Nếu idx = -1, hàm f của ta trả về 1 nếu sum = 0 và 0 trong các trường hợp còn lại. Đồng thời, việc chuyển trạng thái sum sang sum' cũng thay đổi thành sum' = (sum + v) \\mod{D}.","Một điều nữa là hàm f cũng sẽ xét cả số 0 mặc dù bài toán không yêu cầu nên kết quả bài toán sẽ là: (G(K) - 1) \\mod{10^9 + 7}.","Độ phức tạp của thuật toán này là O(10 \\times n \\times 2 \\times D)."]},{"i":"ví-dụ-3-số-lượng-số---snad","l":"Ví dụ 3: Số lượng số - SNAD","p":["Đề bài: Số lượng số","Tóm tắt: Cho T cặp số [X; Y], đếm số lượng số mà có tích của một số với tổng chữ số của nó đó nằm trong khoảng [X; Y].","Giới hạn: T \\lt 21, 0 \\lt X \\le Y \\lt 10^{19}.","Gọi A là một số thỏa mãn điều kiện. Vì A thỏa mãn điều kiện nên:","X \\le A \\times d(A)\\le Y","Với d(A) là tổng các chữ số của A.","Ta thấy rằng các số X, Y, A là các số rất lớn, nhưng d(A) lại nhỏ một cách bất ngờ - d(x) \\le 171, \\forall{x} \\lt 10^{19}.","Từ đây, ta có thể viết lại công thức trên như sau:","\\left\\lfloor \\frac{X}{d(A)}\\right\\rfloor \\le A \\le \\left\\lfloor \\frac{Y}{d(A)}\\right\\rfloor","Qua công thức này, ta đã chuyển đổi bài toán sang một dạng khác đơn giản hơn: Cho S chạy từ 1 đến 171, đếm số lượng số từ \\left\\lfloor \\frac{X}{S}\\right\\rfloor đến \\left\\lfloor \\frac{Y}{S}\\right\\rfloor có tổng chữ số bằng S.","Tổng các số đếm được sẽ là đáp án của bài toán gốc.","Ta có 3 trạng thái QHĐ: (idx, smaller, sum).","Nếu idx = -1, hàm f sẽ trả về 1 nếu sum = S và trả về 0 trong các trường hợp còn lại.","Việc chuyển đổi trạng thái (idx, smaller, sum), sang (idx', smaller', sum') sẽ tương tự ví dụ 1.","Độ phức tạp của thuật toán này là O((10 \\times n \\times 2 \\times sum) \\times 171 \\times T)."]},{"l":"Tối ưu QHĐ chữ số","p":["Nhiều bài toán QHĐ chữ số (giống như bài này) có thể yêu cầu ta tính đi tính lại các khoảng số với cùng một tính chất. việc này vô tình làm cho thuật toán của ta chạy chậm đi khi phải tính đi tính lại các số.","Một cách tối ưu cực kì hay ho chính là ta sẽ chỉ thực hiện việc memset một lần ở ngoài hàm G, đồng thời bỏ trạng thái smaller khi lưu kết quả của trạng thái.","Vì các giá trị của trạng thái QHĐ có smaller = 0 phụ thuộc vào một giá trị cụ thể, nên không thể sử dụng lại cho các số tiếp theo. Bằng cách loại bỏ trạng thái smaller khi lưu kết quả của trạng thái và xét riêng từng trường hợp smaller, ta có thể sử dụng lại các kết quả đã được tính ở những lần trước.","Có thể xem qua đoạn code của bài toán khi áp dụng cách cài đặt mới:","Độ phức tạp của thuật toán giờ đây giảm xuống còn: O(10 \\times n \\times sum)"]},{"i":"ví-dụ-4-numtst---369-numbers","l":"Ví dụ 4: NUMTST - 369 Numbers","p":["Đề bài: NUMTSN - 369 Numbers","Tóm tắt: Cho T cặp số A và B, với mỗi cặp số, đếm số lượng số 369 nằm trong khoảng [A; B], modulo 10^9 + 7.","Một số X là số 369 khi số lượng chữ số 3 bằng số lượng chữ số 6 và bằng số lượng chữ số 9 và có ít nhất một chữ số 3.","Giới hạn: T \\lt 100, 1 \\le A \\le B \\le 10^{50}.","Ta có 5 trạng thái QHĐ: (idx, smaller, three, six, nine) với idx, smaller có định nghĩa như các ví dụ trước và three, six, nine là số lượng số 3, 6, và 9.","Nếu idx = -1, hàm f trả về 1 nếu three > 0, three = six = nine, và 0 trong các trường hợp còn lại.","Nếu trạng thái của ta đang là (idx, smaller, three, six, nine), và ta điền a_{idx} = v, ta sẽ chuyển trạng thái tiếp theo (idx', smaller', three', six', nine'):","idx', smaller' giống các ví dụ trước.","three' = three + 1 nếu v = 3 hoặc three' = three nếu v \\neq 3.","six' = six + 1 nếu v = 6 hoặc six' = six nếu v \\neq 6.","nine' = nine + 1 nếu v = 9 hoặc nine' = nine nếu v \\neq 9.","Vì A, B là những số rất lớn, ta áp dụng cách tính thứ hai được nói ở phần lý thuyết: (G(b) - G(a) + g(a)) \\mod{10^9 + 7}.","Độ phức tạp của thuật toán là: O(10 \\times n \\times three \\times six \\times nine)."]},{"i":"ví-dụ-5-số-đặc-biệt---pearlnum","l":"Ví dụ 5: Số đặc biệt - Pearlnum","p":["Đề bài: Số đặc biệt","Tóm tắt: Ta có hàm f(x) trả về tổng bình phương các chữ số trong x. Một số x được gọi là số đặc biệt nếu x = 1 sau khi áp dụng không hoặc nhiều lần công thức: x = f(x). Cho T cặp số [L, R], hãy cho biết số lượng số đặc biệt trong khoảng [L, R].","Giới hạn: T \\le 100, 1 \\le L \\le R \\le 10^{18}.","Một điều dễ nhận thấy đối với bài toán này là với mỗi x \\le 10^{18}, f(x) \\le 1458. Vì vậy, ta có thể viết lại bài toán như sau: hãy cho biết số lượng số x trong khoảng [L, R] mà f(x) là số đặc biệt.","Việc tìm các số đặc biệt \\le 1458 có thể được thực hiện một cách đơn giản.","Ta có 3 trạng thái QHĐ: (idx, smaller, sum) với idx, smaller có định nghĩa như các ví dụ trước và sum là tổng bình phương các chữ số đã được điền.","Nếu idx = -1, hàm f trả về 1 nếu sum là một số đặc biệt và 0 nếu không là số đặc biệt.","Nếu trạng thái của ta đang là (idx, smaller, sum), và ta điền a_{idx} = v, ta sẽ chuyển trạng thái tiếp theo (idx', smaller', sum'):","idx', smaller' giống các ví dụ trước.","sum' = sum + v^2.","Độ phức tạp của thuật toán này là: O([10 \\times n \\times (n \\times 81)])."]},{"i":"ví-dụ-6-lucky13","l":"Ví dụ 6: LUCKY13","p":["...","Đề bài: LUCKY13","Độ phức tạp của thuật toán này là O(10 \\times 2 \\times n).","Đồng thời, nếu one = 1 thì ta không được điền a_{idx} = 3.","Giới hạn: 0 \\le X \\le Y \\le 10^{15}.","idx', smaller' giống các ví dụ trước.","isFalling: biểu thị nếu a_{n - 1} \\ge a_{n - 2} \\ge ... \\ge a_{idx + 1} đúng hoặc sai.","isRising: biểu thị nếu a_{n - 1} \\le a_{n - 2} \\le ... \\le a_{idx + 1} đúng hoặc sai.","Nếu idx = -1, hàm f trả về 1.","Nếu trạng thái của ta đang là (idx, smaller, one), và ta điền a_{idx} = v, ta sẽ chuyển trạng thái tiếp theo (idx', smaller', one'):","Ngoài các trạng thái biểu thị đoạn số \\overline{a_{n - 1}a_{n - 2}...a_{idx + 1}} quen thuộc như sum, ta còn có một số trạng thái phổ biến khác như:","nonz: biểu thị nếu \\overline{a_{n - 1}a_{n - 2}...a_{idx + 1}} là các chữ số không vô nghĩa.","one' = 1 nếu v = 1, one = 0 nếu v \\neq 1.","prevDigit: biểu thị giá trị của a_{idx + 1}.","s: tập hợp các phần tử phân biệt \\\\{a_{n - 1}, a_{n - 2}, ..., a_{idx + 1}\\\\}.","Ta có 3 trạng thái QHĐ: (idx, smaller, one) với idx, smaller có định nghĩa như các ví dụ trước và one với one = 1 nếu số được điền ở vị trí idx + 1 bằng 1 và one = 0 trong trường hợp còn lại.","Tóm tắt: Cho một hoặc nhiều cặp số nguyên không âm A và B, đếm số lượng các số trong khoảng [A, B] mà trong dạng biểu diễn không có số 13."]}],[{"l":"Giới thiệu về lí thuyết đồ thị","p":["Trước khi đến với lí thuyết đồ thị, ta có một câu hỏi nhỏ như sau:","Thành phố Königsberg thuộc Phổ, nay là Kaliningrad thuộc Nga, là một thành phố nằm ở 2 bên sông Pregel và có 2 hòn đảo lớn Kneiphof và Lomse. Trước kia, 2 hòn đảo được kết nối với nhau và với 2 bên bờ sông bằng 7 cây cầu.","Königsberg","Hình ảnh thành phố Königsberg","Bài toán đặt ra ở đây là: Hãy tìm một con đường đi qua 7 cây cầu ít nhất một lần và chỉ một lần duy nhất.","Bài toán này - bài toán 7 cầu ở Königsberg, đã được giải bởi nhà toán học Leonhard Euler vào thế kỉ XVIII và đã cho ra đời định lý đầu tiên về lý thuyết đồ thị.","Ở chương này, ta sẽ tìm hiểu về lý thuyết đồ thị: định nghĩa, các dạng của đồ thị, một số khái niệm, tính chất liên quan, cách lưu trữ đồ thị trong chương trình và một số thuật toán liên quan đến đồ thị."]}],[{"l":"Lí thuyết đồ thị","p":["Được xuất hiện trên VNOI Wiki"]},{"l":"Định nghĩa","p":["Hình ảnh dưới đây là một ví dụ về một đồ thị:","Hình ảnh về đồ thị","Những vòng tròn được gọi là các đỉnh (vertices) hoặc các nút (nodes), và những đường thẳng nối những vòng tròn được gọi là các cạnh (edges).","Về cơ bản, đồ thị là một tập hợp hữu hạn gồm các đỉnh và được nối với nhau bởi các cạnh.","Một đồ thị G sẽ được kí hiệu: G = (V, E)","Với V là tập hợp chứa các đỉnh, và E là tập hợp chứa các cạnh, mỗi cạnh có dạng một cặp giá trị {u, v}(có thể được viết thành uv). Ví dụ:","G= {1, 2, 3, 4, 5, 6}, {1, 2}, {1, 5}, {2, 5}, {2, 3}, {3, 4}, {4, 5}, {4, 6}","chính là đồ thị ở hình ví dụ trên.","Tập hợp đỉnh V của đồ thị G được kí hiệu V(G), tập hợp cạnh được kí hiệu E(G)."]},{"l":"Các dạng đồ thị","p":["Các dạng đồ thị được nói đến dưới đây là một số dạng đồ thị phổ biến trong lập trình thi đấu."]},{"l":"Đơn đồ thị","p":["Một đồ thị không có khuyên, không có các cạnh song song, vô hướng và không có trọng số được gọi là đơn đồ thị(hay chỉ đơn giản là đồ thị).","Note:","Khuyên là các cạnh có dạng uu.","Hai hoặc nhiều cạnh song song với nhau khi các cạnh có chung hai điểm đầu mút."]},{"l":"Đa đồ thị","p":["Một đồ thị tồn tại các cạnh song song được gọi là đa đồ thị.","Đơn đồ thị là một dạng đặc biệt của đa đồ thị."]},{"l":"Đồ thị vô hướng","p":["Một đồ thị là vô hướng (undirected) khi cạnh không được chỉ định hướng. Nếu đồ thị tồn tại một cạnh uv, ta có thể đi theo hướng u \\rightarrow v và hướng v \\rightarrow u. Khi này, việc viết 2 cạnh uv và vu là như nhau và ta chỉ cần viết 1 trong 2 cạnh."]},{"l":"Đồ thị có hướng","p":["Một đồ thị là có hướng (directed) khi cạnh được chỉ định hướng. Điều này có nghĩa rằng nếu đồ thị tồn tại một cạnh uv, ta chỉ có thể đi theo hướng u \\rightarrow v. Khi này, 2 cạnh uv và vu phân biệt.","Ta có thể gọi các cạnh trong đồ thị có hướng là cung (arc)."]},{"l":"Đồ thị có trọng số","p":["Một đồ thị có trọng số (weighted) là một đồ thị có các cạnh được gán một giá trị. Các giá trị có thể tượng trưng cho khoảng cách, chi phí di chuyển,..."]},{"l":"Đồ thị không có trọng số","p":["Một đồ thị không có trọng số (unweighted) là một đồ thị các cạnh không được gán giá trị. Có thể nhìn dạng đồ thị này theo cách khác rằng đồ thị không trọng số là một đồ thị có trọng số với các cạnh được gán giá trị bằng nhau (Ví dụ như có trọng số bằng 1)."]},{"l":"Đồ thị con","p":["Một đồ thị G_s = (V, E) là đồ thị con (subgraph) của một đồ thị G = (V, E) khi tập đỉnh và tập cạnh của G_s là tập con của các tập hợp tương ứng của G, hay $V(G_s) \\subseteq V(G) $ và $E(G_s) \\subseteq E(G) $ thỏa mãn."]},{"l":"Các dạng đồ thị đặc biệt","p":["Một số dạng đồ thị đặc biệt ta cần biết."]},{"l":"Đồ thị đầy đủ","p":["Một đồ thị là đầy đủ khi tất cả các cặp đỉnh của đồ thị được nối với nhau bởi một cạnh.","Nếu một đồ thị G có |V| đỉnh vừa vô hướng vừa đầy đủ, số cạnh của G sẽ là |E| = \\frac{|V| \\times (|V| - 1)}{2}."]},{"l":"Đồ thị hai phía","p":["Một đồ thị là hai phía (bipartite) khi tập đỉnh của nó có thể chia làm hai tập X và Y rời nhau sao cho không cặp đỉnh nào nối với nhau với mỗi tập."]},{"i":"directed-acyclic-graph-dag","l":"Directed acyclic graph (DAG)","p":["DAG là một đồ thị có hướng không có chu trình. Một đồ thị có hướng được gọi là một DAG khi và chỉ khi đồ thị tồn tại thứ tự tô pô.","DAG"]},{"l":"Cây","p":["Một đồ thị được gọi là một cây khi nó là một đồ thị vô hướng, liên thông và không có chu trình."]},{"i":"các-khái-niệm-tính-chất","l":"Các khái niệm, tính chất","p":["Ta cùng điểm qua một số khái niệm, tính chất liên quan đến đồ thị."]},{"i":"đỉnh-kề-cạnh-liền-thuộc-đỉnh","l":"Đỉnh kề, cạnh liền thuộc, đỉnh","p":["Cho một đồ thị G = (V, E):","1. Hai đỉnh u và v của G kề nhau (adjacent) khi uv \\in E, hay uv là một cạnh của G. Khi này, ta nói cạnh uv là cạnh liên thuộc (incident) với hai đỉnh u và v, đồng thời u, v là hai đỉnh đầu mút (endpoints) của cạnh uv.","2. Cho đỉnh u \\in V, các đỉnh hàng xóm (neighbours) với đỉnh u là tất cả các đỉnh v \\in V thỏa mãn uv \\in E, hay tất cả các đỉnh v kề với u.","3. Cho đỉnh u \\in V, bậc (degree) của đỉnh u chính là số lượng hàng xóm của đỉnh u. Kí hiệu: deg(u). Ta có một số bổ đề về bậc như bổ đề bắt tay:\\sum_{u \\in V} deg(u) = 2|E| Nếu G là một đồ thị có hướng, ta định nghĩa:","Bán bậc ra (out-degree) của đỉnh u, kí hiệu deg^+(u), là số lượng cạnh xuất phát từ đỉnh u, hay giá trị của |\\{v \\in V | uv \\in E\\}|.","Bán bậc vào (in-degree) của đỉnh u kí hiệu deg^-(u), là số lượng cạnh kết thúc tại đỉnh u, hay giá trị của |\\{v \\in V | vu \\in E\\}|.","Trong đồ thị có hướng, tổng bán bậc vào của tất cả các đỉnh luôn bằng tổng bán bậc ra của tất cả các đỉnh (vì mỗi cạnh có một đỉnh bắt đầu và một đỉnh kết thúc)."]},{"i":"đường-đi-chu-trình","l":"Đường đi, chu trình","p":["1. Một đường đi (walk)(trong G) là một dãy các đỉnh (v_0, v_1, v_2,..., v_k) thuộc G và các cạnh (v_0v_1, v_1v_2,..., v_{k - 1}v_k) là các cạnh thuộc đồ thị.","2. Với w = (v_0, v_1, v_2,..., v_k) là một đường đi trong G, ta có:","3. Một đường đi khép kín (closed walk, tour) của G một đường đi mà đỉnh cuối trùng với đỉnh đầu. Hay nói cách khác, là một dãy các đỉnh (v_0, v_1, v_2,..., v_k) với v_0 = v_k.","4. Một chu trình (cycle) của G là một đường đi khép kín (v_0, v_1, v_2,..., v_k) với k \\ge 3 và các đỉnh (v_0, v_1, v_2,..., v_{k - 1}) đôi một phân biệt. Một số trường hợp đặc biệt:","5. Một đường đi (chu trình) là sơ cấp nếu nó không đi qua đỉnh nào hai lần trở lên. Một đường đi (chu trình) là đơn giản nếu nó không đi qua cạnh nào hai lần trở lên.","Cho hai đỉnh p và q thuộc G, ta nói đường đi từ p đến q là đường đi bắt đầu từ đỉnh p và kết thúc tại đỉnh q.","Cho một đồ thị G = (V, E):","Độ dài (khoảng cách) của đường đi w là một số nguyên không âm k( k tương đương với số cạnh trên đường đi, và k + 1 tương đương với số đỉnh). Nếu G có trọng số, độ dài của đường đi là tổng trọng số của các cạnh trên đường đi.","G tồn tại chu trình có 1 đỉnh nếu trong đồ thị tồn tại cạnh khuyên. Ví dụ: 1_node_cycle","Một path là một đường đi trong đó tất cả các đỉnh trên đường đi đôi một phân biệt (suy ra các cạnh trên đường đi cũng đôi một phân biệt).","Một trail là một đường đi trong đó tất cả các cạnh trên đường đi đôi một phân biệt.","Nếu G là một đồ thị có hướng hoặc là một đa đồ thị, G tồn tại chu trình có 2 đỉnh khi trong đồ thị tồn tại hai đỉnh a và b được nối với nhau bởi 2 cạnh song song. Ví dụ: 2_node_cycle","v_0 được gọi là đỉnh đầu (starting point) của w, ta nói w bắt đầu tại tại đỉnh v_0.","v_0, v_1, v_2,..., v_k là các đỉnh của w.","v_0v_1, v_1v_2,..., v_{k - 1}v_k là các cạnh của w.","v_k được gọi là đỉnh cuối (ending point) của w, ta nói w kết thúc tại tại đỉnh v_k."]},{"i":"tính-liên-thông-khớp-cầu","l":"Tính liên thông, khớp, cầu","p":["Cho một đồ thị G = (V, E):","1. Hai đỉnh u và v của G liên thông nếu tồn tại ít nhất 1 đường đi từ u đến v.","2. G liên thông (connected) khi mọi cặp đỉnh của G tồn tại đường đi. G song liên thông (biconnected) nếu nó liên thông và không có đỉnh khớp, nghĩa là nếu xóa một đỉnh bất kì thì đồ thị vẫn liên thông.","3. Đối với một đồ thị có hướng:","Một đồ thị có hướng G được gọi là liên thông mạnh (strongly connected) nếu mọi cặp đỉnh của G tồn tại đường đi.","Một đồ thị có hướng G được gọi là liên thông yếu (weakly connected) nếu khi ta xem đồ thị G là một đồ thị vô hướng thì G liên thông.","4. Đỉnh u thuộc G được gọi là khớp (articulation point) nếu khi ta xóa bỏ đỉnh u khỏi đồ thị thì G không còn liên thông.","5. Cạnh uv thuộc G được gọi là cầu (bridge) nếu khi ta xóa bỏ cạnh uv khỏi đồ thị thì G không còn liên thông.","6. Nếu G không liên thông, G sẽ tồn tại nhiều đồ thị con liên thông, rời nhau. Mỗi đồ thị con đó được gọi là một thành phần liên thông (TPLT) (connected component) của G."]},{"i":"cây-1","l":"Cây","p":["Đối với các đồ thị cây, ta có thêm một số định nghĩa và tính chất:","Cho một đồ thị G = (V, E):","1. G là cây khi nó thỏa mãn ít nhất 2 điều kiện dưới đây:","G không có chu trình","G liên thông","Số cạnh bằng số đỉnh trừ 1 hay |E(G)| = |V(G)| - 1","2. G là một rừng cây (forest) khi G có nhiều hơn 1 TPLT, mỗi TPLT là một cây.","3. Chỉ tồn tại một đường đi độc nhất nối 2 đỉnh bất kì trên G.","4. Thêm một cạnh bất kì chưa có trong G sẽ xuất hiện một chu trình.","Đồng thời, việc xóa một cạnh bất kì trong G sẽ làm tăng số TPLT của cây \\rightarrow tất cả các cạnh của G đều là cạnh cầu."]},{"i":"gốc-lá-quan-hệ-giữa-các-đỉnh-trong-cây","l":"Gốc, lá, quan hệ giữa các đỉnh trong cây","p":["Cho một đồ thị cây T = (V, E):","1. Gốc (root) của T là một đỉnh thuộc T được lựa chọn làm gốc. Thông thường, các bài toán đều chọn đỉnh 1 làm gốc của cây, nếu bài toán không chỉ rõ gốc của cây là đỉnh nào, hãy giả sử nó là đỉnh 1. Một số cây có thể không có gốc.","2. Đỉnh lá (leaf) của T là các đỉnh có bậc bằng 1.","3. Nếu T có gốc, các đỉnh thuộc T sẽ hình thành quan hệ cha/con (parent/child). Cụ thể:","Với mỗi cặp cạnh uv bất kì: nếu khoảng cách tới gốc của v ngắn hơn hơn khoảng cách tới gốc của u, đỉnh v sẽ là cha (parent) của đỉnh u. Nếu khoảng cách tới gốc của v dài hơn thì đỉnh v sẽ là con (child) của đỉnh u.","Một đỉnh có thể có nhiều con, nhưng chỉ có một cha.","Đỉnh gốc và đỉnh lá là ngoại lệ của tính chất trên, với đỉnh gốc không có cha, đỉnh lá không có con.","Đỉnh có khoảng cách tới gốc ngắn hơn sẽ là tổ tiên (ancestor) của đỉnh có khoảng cách tới gốc xa hơn. Ngược lại, đỉnh xa hơn sẽ là hậu duệ (descendant) của đỉnh gần hơn.","Tổ tiên thứ k (Kth-ancestor) của một đỉnh u là một đỉnh v có hậu duệ là đỉnh u và khoảng cách của 2 đỉnh đúng bằng k.","4. Khoảng cách từ gốc đến một đỉnh được gọi là chiều cao (height) hoặc chiều sâu (depth) của đỉnh. Chiều cao của cây T là giá trị của đỉnh có chiều cao lớn nhất.","5. Đường kính (diameter) của cây T là khoảng cách lớn nhất giữa hai đỉnh trong cây."]},{"l":"Tổ chức dữ liệu","p":["Có 3 cách phổ biến để biểu diễn đồ thị trong chương trình: ma trận kề, danh sách kề và danh sách cạnh. Tùy theo đề bài mà ta sẽ áp dụng các cách lưu trữ khác nhau.","Ta giả sử dữ liệu nhập của một đồ thị là một danh sách cạnh.","Đồ thị ví dụ:","Đồ thị"]},{"i":"ma-trận-kề-adjacency-matrix","l":"Ma trận kề (Adjacency Matrix)","p":["Ma trận kề là một cấu trúc đơn giản được dùng để lưu một đồ thị bất kì.","Để biểu diễn đồ thị G(V, E) trong ma trận kề, ta xây dựng ma trận vuông A với:","A[u][v] = 1 nếu uv \\in E(G)","A[u][v] = 0 nếu uv \\notin E(G)","1","2","3","4","5","6","0","Ngoài ra:","Nếu đồ thị có trọng số, ta thay 1 bằng trọng số của cạnh tương ứng.","Nếu đồ thị vô hướng, ta đánh dấu cả A[x][y] và A[y][x], còn nếu có hướng thì chỉ đánh dấu A[x][y]."]},{"i":"danh-sách-kề-adjacency-list","l":"Danh sách kề (Adjacency List)","p":["1, 2, 5","1, 3, 5","2, 4","2, 5","3, 5, 6","4","adj[1]","adj[2]","adj[3]","adj[4]","adj[5]","adj[6]","Các đỉnh kề","Danh sách kề là cách lưu trữ đồ thị phổ biến trong lập trình thi đấu. Để biểu diễn đồ thị bằng danh sách kề, ta tạo N mảng giá trị, mảng giá trị thứ u lưu danh sách các đỉnh kề với đỉnh u.","Mảng danh sách kề","Nếu đồ thị có trọng số thì với mỗi cạnh (a, b) có trọng số w, ta lưu cặp giá trị (b, w) trong adj[a]. Có thể lưu cặp giá trị (b, w) bằng kiểu dữ liệu pair."]},{"i":"danh-sách-cạnh-edge-list","l":"Danh sách cạnh (Edge List)","p":["Danh sách cạnh được dùng để lưu các cạnh trong đồ thị.","Ta có thể lưu các cạnh của đồ thị bằng pair hoặc tạo một cấu trúc struct tùy ý để lưu cặp giá trị có trong cạnh của đồ thị."]}],[{"l":"Thuật toán sắp xếp Tô-pô"},{"l":"Thứ tự Tô-pô","p":["Thứ tự tô-pô (Topological Ordering) của một đồ thị có hướng G = (V, E) là thứ tự sắp xếp của các đỉnh trên một đoạn thẳng sao cho với mỗi cạnh uv, đỉnh u đứng trước đỉnh v trong thứ tự sắp xếp.","Thứ tự Tô-pô có tính ứng dụng cao trong thực tế. Ví dụ trong việc sắp xếp lịch trình, xem các đỉnh là các sự kiện, và các cạnh thể hiện rằng một sự kiện phải xảy ra trước sự kiện khác, thứ tự tô-pô sẽ cho ta biết các sự kiện nào cần phải hoàn thành trước, và cho ta một lịch trình giúp ta không bỏ lỡ một sự kiện nào.","Không phải đồ thị có hướng nào cũng có thứ tự tô-pô. Nếu đồ thị xuất hiện chu trình, việc tìm thứ tự tô-pô là điều không thể, bởi vì các đỉnh trong chu trình không thể đứng trước một đỉnh khác cũng nằm trong chu trình ấy. Chỉ có DAG là dạng đồ thị có một hoặc nhiều thứ tự tô-pô."]},{"l":"Thuật toán","p":["Có hai cách chính giúp ta thực hiện sắp xếp tô-pô của một đồ thị có hướng G: DFS và thuật toán Kahn. Ta sẽ tìm hiểu vè hai thuật toán này. Ta giả sử G là một DAG."]},{"l":"DFS","p":["Ta có thể thực hiện sắp xếp tô-pô bằng thuật toán DFS.","Với mỗi đỉnh chưa được ghé thăm, ta thực hiện DFS. Ở cuối hàm DFS, ta sẽ thêm đỉnh ấy vào một danh sách. Danh sách đấy sẽ chứa thứ tự tô-pô đảo.","Độ phức tạp thuật toán: O(|V| + |E|)."]},{"l":"Thuật toán Kahn","p":["Thuật toán Kahn là một thuật toán sắp xếp thứ tự tô-pô.","Thuật toán có cách thức hoạt động khá đơn giản:","Chọn một đỉnh u bất kì trong đồ thị có bán bậc vào bằng 0. Sau khi thêm đỉnh u vào danh sách thứ tự tô-pô, xóa đỉnh u khỏi đồ thị và các cạnh có đỉnh đầu mút bằng u.","Lặp lại quá trình trên cho tới khi không còn đỉnh trong đồ thị.","Độ phức tạp thuật toán: O(|V| + |E|)"]},{"l":"Kiểm tra DAG","p":["Để có thứ tự tô-pô của một đồ thị có hướng, ta cần xác định nếu đồ thị có xuất hiện chu trình hay không. Nếu có chu trình, ta không thể tìm được thứ tự tô-pô và nếu không thì ngược lại","Đối với DFS, ta cần phát hiện sự tồn tại của chu trình trong đồ thị nếu muồn tìm thứ tự tô-pô.","Đối với thuật toán Kahn, để xác định đồ thị có phải là DAG hay không, ta chạy thuận toán và xét kích cỡ của danh sách topo: nếu kích thước của topo bằng n, đồ thị là một DAG và tồn tại thứ tự tô-pô. Nếu điều này không xảy ra, đồ thị của ta có chu trình và không phải DAG."]}],[{"l":"Các thuật toán tìm kiếm trên đồ thị","p":["Khi giải quyết nhiều bài toán lý thuyết đồ thị, ta phải duyệt qua tất cả các đỉnh của đồ thị đó. Cho nên, ta cần phải sử dụng các thuật toán có khả năng duyệt toàn bộ các đỉnh của đồ thị, gọi chung là thuật toán duyệt đồ thị, hay tìm kiếm trên đồ thị.","Ta sẽ tìm hiểu về 2 thuật toán tìm kiếm khác nhau trên đồ thị:","Thuật toán tìm kiếm theo chiều sâu (Depth-First Search - DFS)","Thuật toán tìm kiếm theo chiều rộng (Breadth-First Search - BFS)","Hai thuật toán mặc dù đều thực hiện việc duyệt đồ thị, nhưng quy trình duyệt và cách áp dụng có đôi phần khác nhau."]}],[{"i":"thuật-toán-tìm-kiếm-theo-chiều-rộng-breadth-first-search---bfs","l":"Thuật toán tìm kiếm theo chiều rộng (Breadth-First Search - BFS)","p":["Thuật toán tìm kiếm theo chiều rộng (Breadth-First Search - BFS) là một thuật toán tìm kiếm trên đồ thị."]},{"l":"Thuật toán","p":["Xuất phát từ đỉnh gốc s, thuật toán BFS sẽ thực hiện việc duyệt đồ thị theo chiều rộng (breadth-first). Thuật toán bắt đầu bằng việc duyệt tất cả các đỉnh hàng xóm của đỉnh s(lớp thứ nhất), các đỉnh kề với các đỉnh hàng xóm của đỉnh s(lớp thứ hai), cứ tiếp tục như thế, từng lớp một, cho tới khi ta xét hết tất cả các đỉnh có thể duyệt được từ đỉnh s. Chính vì tính chất duyệt theo từng lớp như thế nên thuật toán còn có tên gọi khác là thuật toán loang.","Ta có một đồ thị vô hướng:","Đơn đồ thị","Giả sử ta bắt đầu thực hiện BFS từ đỉnh 1, thuật toán BFS sẽ duyệt đỉnh 1, sau đó, duyệt qua các đỉnh 2, 3 và 4, và cuối cùng là các đỉnh 3, 5 và 6.","Độ phức tạp thời gian của thuật toán BFS cũng tương tự với độ phức tạp của thuật toán DFS."]},{"l":"Cài đặt","p":["Việc cài đặt thuật toán BFS là một việc đơn giản nếu ta sử dụng CTDL Queue. Ban đầu, đỉnh gốc s sẽ được thêm vào queue của ta. Sau đó, thuật toán sẽ thực hiện 2 bước chính:","Lấy giá trị và loại bỏ đỉnh u ở đầu queue.","Với mỗi đỉnh v kề với đỉnh u và chưa được ghé thăm: thêm đỉnh v vào cuối queue.","Thuật toán sẽ thực hiện việc duyệt cho tới khi tất cả các đỉnh tồn tại đường đi từ đỉnh gốc đã được ghé thăm."]}],[{"i":"thuật-toán-tìm-kiếm-theo-chiều-sâu-depth-first-search---dfs","l":"Thuật toán tìm kiếm theo chiều sâu (Depth-First Search - DFS)","p":["Thuật toán tìm kiếm theo chiều sâu (Depth-First Search - DFS) là một thuật toán tìm kiếm/duyệt trên đồ thị."]},{"l":"Thuật toán","p":["Xuất phát từ một đỉnh u, thuật toán DFS sẽ thực hiện việc duyệt đồ thị theo chiều sâu (depth-first). Ở mỗi bước, thuật toán sẽ chọn một đỉnh bất kì kề với đỉnh u mà chưa được duyệt. Sau đó, thuật toán sẽ thực hiện việc duyệt DFS một cách đệ quy đối với đỉnh ấy. Quá trình sẽ lặp lại cho đến khi tất cả hàng xóm của u đã được duyệt. Khi này, thuật toán \"quay lui\" và tiếp tục với các đỉnh hàng xóm chưa được duyệt khác, nếu có.","Ta có một đồ thị vô hướng:","Đơn đồ thị","Giả sử ta bắt đầu thực hiện DFS từ đỉnh 1, quá trình của thuật toán sẽ diễn ra như sau: 1 \\rightarrow 2 \\rightarrow 5 \\rightarrow(quay lui về 2) \\rightarrow 6 \\rightarrow(quay lui về 2) \\rightarrow 3 \\rightarrow 4 \\rightarrow(quay lui về 3) \\rightarrow(quay lui về 2) \\rightarrow(quay lui về 1).","Khi thực hiện thuật toán DFS, ta nhận thấy mỗi đỉnh của đồ thị sẽ được duyệt nhiều nhất 1 lần, và mỗi cạnh sẽ được duyệt nhiều nhất 2 lần đối với đồ thị vô hướng, hoặc 1 lần đối với đồ thị có hướng.","Tùy vào cách tổ chức đồ thị mà nó sẽ anh hưởng đến độ phức tạp của thuật toán DFS, với các độ phức tạp thời gian O(|V|^2), O(|V| + |E|), O(|V|\\times |E|) nếu ta sử dụng ma trận kề, danh sách kề hoặc danh sách cạnh theo thứ tự tương ứng."]},{"l":"Cài đặt","p":["Việc cài đặt DFS là một việc vô cùng đơn giản. Một chương trình thực hiện DFS điển hình sẽ sử dụng một mảng giá trị vst chứa n phần tử ( n là số lượng đỉnh trong đồ thị) biểu thị nếu đỉnh u đã được duyệt hay chưa, và một danh sách kề adj lưu thông tin về đồ thị:"]},{"l":"Cài đặt bằng stack","p":["Như đã được nói ở phần stack, ta có thể cài đặt DFS bằng cách sử dụng stack, mặc dù cách cài đặt này không phổ biến bằng cách cài đặt ở trên."]}],[{"l":"Ứng dụng của thuật toán tìm kiếm","p":["Hai thuật toán tìm kiếm trên đồ thị đã được nói ở phần trước tuy đơn giản nhưng lại có tính ứng dụng rất cao. Ta sẽ điểm qua một số ứng dụng của nó."]},{"l":"Xây dựng cây khung của đồ thị","p":["Ta có một đồ thị G = (V, E). Nếu ta có một đồ thị G' = G và loại bỏ một số cạnh của G' sao cho G' là một cây và các đỉnh vẫn liên thông thì đồ thị G' được gọi là cây khung của G.","Cây khung","Các cạnh màu cam là các cạnh thuộc cây khung của đồ thị. Có thể có nhiều hơn một cây khung.","Để xây dựng cây khung từ các thuật toán kìm kiếm, ta làm theo cách sau: khi thuật toán DFS hoặc BFS di chuyển từ đỉnh u sang đỉnh v, ta thêm cạnh uv vào cây khung. Ta sẽ gọi cây khung tạo nên từ DFS và BFS lần lượt là cây DFS và cây BFS.","Cây DFS","Cây BFS","Cây DFS có gốc là 1","Cây BFS có gốc là 1"]},{"l":"Tìm thành phần liên thông","p":["Có thể dễ dàng nhận thấy rằng khi ta thực hiện DFS hoặc BFS một đỉnh s bất kì trên một đồ thị vô hướng, hai thuật toán này sẽ đi đến những đỉnh liên thông với s. Từ đấy ta tìm ra được một thành phần liên thông trên đồ thị, với các đỉnh là đỉnh s và các đỉnh liên thông với nó."]},{"l":"Flood fill","p":["Trong nhiều phần mềm vẽ, tồn tại công cụ có tên gọi bucket giúp ta tô màu một vùng có màu sắc giống nhau thành màu ta chọn.","Thuật toán giúp công cụ này thành hiện thực có tên gọi là thuật toán flood fill.","Thuật toán flood fill được sử dụng trên mặt phẳng 2 chiều. Xuất phát từ điểm (x, y), thuật toán sẽ đi đến các đỉnh có chung tính chất với đỉnh này. Ta xuất phát từ một đỉnh sang 4 phía (Đông/Tây/Nam/Bắc) hoặc 8 phía (Đông/Tây/Nam/Bắc/Đông Nam/Đông Bắc/Tây Nam/Tây Bắc) của đỉnh.","Đoạn code ví dụ dưới đây là một thuật toán flood fill sẽ tìm trên mặt phẳng 2 chiều kích thước n \\times m những vùng có giá trị 0."]},{"l":"Tìm đường đi ngắn nhất trên đồ thị","p":["BFS có thể tìm đường đi ngắn nhất từ một đỉnh s đến các đỉnh khác trên đồ thị, nếu định nghĩa khoảng cách từ một đỉnh u đến một đỉnh v là số cạnh mà nó cần đi qua."]},{"l":"Kiểm tra đồ thị hai phía","p":["Ta có thể xác định nếu đồ thị của ta là đồ thị hai phía hay không bằng cách tìm chu trình có lẻ đỉnh trong đồ thị.","Ta chỉnh sửa đoạn code ở phần trên như sau: sau khi xác định đường đi ngắn nhất, ta các cặp cạnh uv: nếu khoảng cách của hai đỉnh u, v không đồng chằn hoặc đồng lẻ thì đồ thị không phải đồ thị hai phía. Nếu điều này không xảy ra thì đồ thị của ta là đồ thị hai phía.","Vì chỉ quan tâm tính chẵn lẻ nên ta có thể thay đổi dist lưu tính chẵn lẻ của đường đi ngắn nhất từ đỉnh s.","Mặc dù DFS không thể tính đường đi ngắn nhất, ta vẫn có thể xác định tính hai phía của đồ thị bằng DFS.","Ta có dist[u] là tính chắn lẻ của một đường đi từ s đến u. Sau đó, ta xét trường hợp giống ở trên."]},{"l":"Sắp xếp Tô-pô","p":["Thứ tự tô-pô (Topological Ordering) của một đồ thị có hướng G = (V, E) là thứ tự sắp xếp của các đỉnh trên một đoạn thẳng sao cho với mỗi cạnh uv, đỉnh u đứng trước đỉnh v trong thứ tự sắp xếp.","Ta có thể tìm thứ tự tô-pô của một DAG bằng DFS hoặc thuật toán Kahn.","Xem chi tiết tại phần thuật toán sắp xếp Tô-pô."]},{"l":"Phát hiện chu trình","p":["Đối với đồ thị vô hướng, việc xác định sự tồn tại của chu trình khá đơn giản: đồ thị không có chu trình nếu nó là một cây. Nếu không phải cây thì đồ thị chắc chắn có chu trình.","Đối với đồ thị có hướng, ta sẽ giải quyết theo hướng khác bằng DFS.","Trong quá trình đỉnh u của DFS, ta sẽ chia ra làm 3 giai đoạn:","Giai đoạn 1: Chưa được duyệt. Ở giai đoạn này, đỉnh u chưa được xử lí khi DFS đang chạy.","Giai đoạn 2: Đang được xét đến. Ở giai đoạn này, đỉnh u đã được DFS duyệt qua nhưng chưa duyệt xong.","Giai đoạn 3: Đã được xét đến. Ở giai đoạn này, đỉnh u đã được DFS duyệt qua và đã duyệt xong.","Từ 3 giai đoạn này, ta có thể phân loại các cạnh của đồ thị trong quá trình duyệt tạo cây DFS thành các cạnh sau:","Cạnh cây (Tree Edge): đây là cạnh của cây DFS. Khi ta đi từ đỉnh u sang đỉnh v thì cạnh uv là cạnh cây khi đỉnh u ở giai đoạn 2 và đỉnh v ở giai đoạn 1.","Cạnh ngược/hai phía (Back/Bidirectional Edge): đây là cạnh không thuộc cây DFS. Khi ta đi từ đỉnh u sang đỉnh v thì cạnh uv là cạnh ngược khi đỉnh u ở giai đoạn 2 và đỉnh v ở giai đoạn 2. Cạnh ngược giúp ta biết được đỉnh v là tổ tiên của đỉnh u trên cây DFS. Nếu v là cha của đỉnh u thì cạnh của ta là cạnh hai phía.","Cạnh xuôi/chéo (Forward/Cross Edge): đây là cạnh không thuộc cây DFS. Khi ta đi từ đỉnh u sang đỉnh v thì cạnh uv là cạnh xuôi/chéo khi đỉnh u ở giai đoạn 2 và đỉnh v ở giai đoạn 3. Điểm khác nhau giữa cạnh xuôi và cạnh chéo là cạnh xuôi sẽ chỉ một đỉnh đến một đỉnh hậu duệ của nó còn cạnh chéo thì không.","Ta sẽ tìm được chu trình nếu cây DFS tồn tại cạnh ngược trên đồ thị. Chu trình hai đỉnh cũng có thể tồn tại nếu tồn tại cạnh hai phía.","Ở hình ví dụ dưới đây, ta có cây DFS gốc là 1, cạnh màu cam là cạnh cây, cạnh màu đỏ là cạnh ngược, cạnh màu lục là cạnh chéo còn cạnh màu lam là cạnh xuôi."]},{"i":"tìm-khớp-cầu","l":"Tìm khớp, cầu","p":["Bài toán tìm khớp cầu trên đồ thị vô hướng có thể được giải quyết hiệu quả bằng DFS.","Ban đầu, khi bắt đầu duyệt đỉnh u, ta có num[u] = low[u]. Sau đó, trong quá trình duyệt từ đỉnh u, ta cập nhật low[u] thành giá trị nhỏ nhất giữa low[u] và low của các đỉnh nằm trong cây con gốc u trong cây DFS, và num của các đỉnh v được nối với u bởi cạnh ngược.","Các cạnh nét dứt chỉ các cạnh cầu.","Các đỉnh viền xanh chỉ các đỉnh khớp.","Cạnh đỏ chỉ các cạnh ngược không thuộc cây DFS.","Cạnh vàng chỉ các cạnh cây thuộc cây DFS.","Khớp cầu","low: đỉnh có thứ tự duyệt nhỏ nhất có thể đi đến được từ một đỉnh.","Một cạnh uv là cạnh cầu khi low[v] \\gt num[u] với cách giải thích tương tự với đỉnh khớp.","Một đỉnh u là đỉnh khớp khi tồn tại một đỉnh con trên cây DFS v sao cho low[v] \\ge num[u]. Nếu low[v] \\lt num[u] thì v có thể đến được một đỉnh có num nhỏ hơn num[u] bằng cạnh ngược. Nếu điều này không xảy ra, thì để v có thể đi sang các đỉnh khác ngoài các đỉnh trong cây DFS con gốc v, ta cần phải đi qua đỉnh u, và khi xóa đỉnh u đi thì v không thể đi đến các đỉnh ấy \\rightarrow đỉnh u là đỉnh khớp.","Một trường hợp nữa của đỉnh khớp là khi đỉnh gốc của cây DFS có ít nhất 2 đỉnh con thì đỉnh gốc cũng là đỉnh khớp.","num: thứ tự duyệt đỉnh của DFS.","Ở hình trên, ta có đồ thị DFS sau khi duyệt đồ thị:","Số bên phải chỉ low của đỉnh v.","Số bên trái chỉ num của đỉnh u.","Ta sẽ lưu hai thông tin trên cây DFS:","Từ những thông tin này, ta có thể xác định khớp cầu trên đồ thị."]},{"l":"Tìm thành phần liên thông mạnh","p":["Có thể sử dụng hai thuật toán tìm TPLT mạnh trên đồ thị có hướng chính là thuật toán của Kosaraju và thuật toán của Tarjan."]},{"l":"Thuật toán Kosaraju","p":["Thuật toán Kosaraju là một thuật toán tìm TPLT mạnh khá đơn giản.","Ta sẽ thực hiện DFS trên đồ thị. Sau mỗi lần duyệt xong một đỉnh u, ta thêm đỉnh u vào một danh sách theo thứ tự ngược lại (nếu đỉnh u được duyệt đầu tiên thì nó sẽ ở cuối danh sách,...).","Sau đó, đảo ngược các cạnh trên đồ thị (cung uv đổi thành cung vu) và thực hiện DFS theo thứ tự các đỉnh có trong danh sách.","Số lần ta thực hiện DFS sẽ là số TPLT mạnh trong đồ thị và các đỉnh mà DFS duyệt đến với mỗi lần gọi là các đỉnh cùng thuộc 1 TPLT mạnh.","Kosaraju"]},{"l":"Thuật toán của Tarjan","p":["Thuật toán của Tarjan là một thuật toán tìm kiếm TPLT mạnh.","Ta sẽ sử dụng num và low giống như phần khớp cầu, tuy nhiên việc cập nhật low sẽ có chút khác biệt. Ta chỉ cập nhât low[u] bằng low[v] nếu ta chưa xác định được v thuộc TPLT mạnh nào.","Ta có thuật toán DFS duyệt như sau:","Khi ta bắt đầu duyệt đỉnh u, ta thêm u vào một stack. Sau khi kết thúc việc duyệt các phần tử kề đỉnh u, nếu num[u] = low[u] thì ta đã tìm được một TPLT, với các đỉnh là những đỉnh nằm trên đỉnh u trong stack. Ta đánh đấu và loại các đỉnh này ra khỏi stack, tiếp tục duyệt các đỉnh khác.","Tarjan","Những đỉnh có cùng màu sắc trong hình là các đỉnh thuộc cùng một TPLT."]}]]